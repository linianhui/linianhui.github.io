<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=google-site-verification content="X6gTMGCy1-_vb5i3aja3ZZyzPY3raiKRJp4VIhOAX24"><meta name=msvalidate.01 content="CDE7502649B75529BD0FCFE89B056E38"><title>[信息安全] 02 密码工具箱 第2部分 - Timetombs</title>
<link rel=icon type=image/svg href=/favicon.svg><link rel=stylesheet href=https://s4.zstatic.net/ajax/libs/normalize/8.0.1/normalize.min.css crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://s4.zstatic.net/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css crossorigin=anonymous referrerpolicy=no-referrer><link href='/asset/blog.css?time=2025-10-26T19%3a03%3a29Z%2b08%3a00' rel=stylesheet type=text/css><script src=https://s4.zstatic.net/npm/currency.js@2.0.4/dist/currency.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://s4.zstatic.net/ajax/libs/moment.js/2.30.1/moment.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src='/asset/blog.js?time=2025-10-26T19%3a03%3a29Z%2b08%3a00' type=application/javascript></script><script type=text/javascript>blog.isMobile()&&document.write('<link href="/asset/blog.mobile.css?time=2025-10-26T19%3A03%3A29Z%2B08%3A00" rel="stylesheet">')</script></head><body><div id=horizontal-progress class=horizontal-progress></div><aside id=toc class=toc><section class=toc-header><a class=toc-page-title href=/information-security/ target=_blank>[信息安全]</a></section><section class=toc-page><a class=toc-page-title href=/information-security/01-cryptography-toolbox-1/ target=_blank>[信息安全] 01 密码工具箱 第1部分</a></section><section class="toc-page selected"><span class=toc-page-title>[信息安全] 02 密码工具箱 第2部分</span><nav id=TableOfContents><ul><li><a href=#pseudo-random-number>1 伪随机数(Pseudo-Random Number)</a><ul><li><a href=#practical-use-of-pseudo-random-number>1.1 伪随机数的实际应用</a></li><li><a href=#attack-pseudo-random-number-generator>1.2 针对伪随机数生成器的攻击</a></li></ul></li><li><a href=#hybrid-cryptosystem>2 混合密码系统</a><ul><li><a href=#practical-use-of-hybrid-cryptosystem>2.1 混合密码系统的实际应用</a></li><li><a href=#leftover-problem>2.2 遗留问题</a></li></ul></li><li><a href=#certificate>3. 证书(Certificate)- 为公钥添加数字签名</a><ul><li><a href=#public-key-infrastructure>3.1 PKI(Public Key Infrastructure)</a></li><li><a href=#public-key-certificate>3.2 公钥证书</a></li><li><a href=#public-key-cryptography-standards>3.3 PKCS(Public Key Cryptography Standards)</a></li></ul></li><li><a href=#summary>4. 总结</a></li><li><a href=#reference>5 参考资料</a></li></ul></nav></section><section class=toc-page><a class=toc-page-title href=/information-security/03-https/ target=_blank>[信息安全] 03 HTTPS工作流程</a></section><section class=toc-page><a class=toc-page-title href=/information-security/04-one-time-password/ target=_blank>[信息安全] 04 一次性密码 & 身份认证</a></section><section class=toc-page><a class=toc-page-title href=/information-security/05-x.509/ target=_blank>[信息安全] 05 X.509 公钥证书的格式标准</a></section><script type=text/javascript>blog.isPC()&&blog.toggleToc()</script></aside><main class=main><header class=header><hgroup class=header-hgroup><h1 class=header-hgroup-title><a href=/>Timetombs</a></h1><h2 class=header-hgroup-subtitle>泛义的工具是文明的基础，而确指的工具却是愚人的器物</h2></hgroup><nav class=header-nav><a class=header-nav-item href=/topic/ title=专题 target=_self><i class="fa fa-folder"></i>专题</a>
<a class=header-nav-item href=/tag/ title=标签 target=_self><i class="fa fa-tags"></i>标签</a>
<a class=header-nav-item href=/archive/ title=归档 target=_self><i class="fa fa-archive"></i>归档</a>
<a class=header-nav-item href=https://linianhui.cnblogs.com title=博客园 target=_black><img src=/asset/cnblogs.favicon.svg>博客园</a>
<a class=header-nav-item href=https://github.com/linianhui/blog title=GitHub target=_black><i class="fa fa-github"></i>GitHub</a></nav><div class=header-stats><div class=stats><span>共
<i>66<sub>h</sub>
</i>/
<i>118<sub>a</sub>
</i>篇</span><div class=stats-date>，更新于 2025-10-26T19:03:29Z+08:00 by &nbsp;
<a class=git-commit href=https://github.com/linianhui/blog/commit/2fac07e818d6d4ad6b78781efea82c28769c8c02 target=_blank><i class="fa fa-code-fork"></i>2fac07e</a></div></div><form class=search method=GET target=_blank action=https://www.bing.com/search><input name=q class=search-input type=search placeholder=search... results=5 onkeypress="search_param.value=search_param_site.value+this.value">
<input id=search_param_site type=hidden value="site:linianhui.github.io ">
<input name=q id=search_param type=hidden></form></div></header><main class=content><article class=article><h1 class=article-title>[信息安全] 02 密码工具箱 第2部分</h1><div class=article-copyright><span>版权声明 - </span><a href=/copyright/cc target=_blank>CC BY-NC-SA 4.0</a></div><section class=article-meta><section class=article-date>2017-07-02 15:08，约5006字，阅读约10分钟</section><section class=article-topics><a class=article-topic href=/information-security/ title=[信息安全] target=_blank><i class="fa fa-folder"></i>[信息安全]</a></section><section class=article-tags><a class=article-tag href=/tag/cer target=_blank><i class="fa fa-tag"></i>cer</a>
<a class=article-tag href=/tag/p12 target=_blank><i class="fa fa-tag"></i>p12</a>
<a class=article-tag href=/tag/pem target=_blank><i class="fa fa-tag"></i>pem</a>
<a class=article-tag href=/tag/pfx target=_blank><i class="fa fa-tag"></i>pfx</a>
<a class=article-tag href=/tag/pki target=_blank><i class="fa fa-tag"></i>PKI</a>
<a class=article-tag href=/tag/%E6%B7%B7%E5%90%88%E5%AF%86%E7%A0%81 target=_blank><i class="fa fa-tag"></i>混合密码</a>
<a class=article-tag href=/tag/%E8%AF%81%E4%B9%A6 target=_blank><i class="fa fa-tag"></i>证书</a>
<a class=article-tag href=/tag/%E9%9A%8F%E6%9C%BA%E6%95%B0 target=_blank><i class="fa fa-tag"></i>随机数</a></section><section class=article-git><a class=article-git-commit href=https://github.com/linianhui/blog/commit/e8a5d272eaab71031c97f4d679e7edceafa475ea target=_blank><i class="fa fa-code-fork"></i>e8a5d27</a>
<span class=article-git-commit-subject>fix markdown</span>
<span class=article-git-commit-time>2023-12-08 07:09</span>
<a class=article-git-source href=https://github.com/linianhui/blog/blob/main/src/information-security/02-cryptography-toolbox-2/index.md target=_blank><i class="fa fa-github"></i>源码</a></section></section><section class=article-content><p>在上一篇<a href=../01-cryptography-toolbox-1/ target=_blank rel="noopener norefferrer">[信息安全] 01 密码工具箱 第1部分</a>中介绍了一些密码技术相关的一些基本工具，同时遗留了<strong>一个鸡生蛋蛋生鸡的问题</strong>和<strong>公钥的认证问题</strong>(￣▽￣)"，这里再补充几个常用的工具先。</p><h1 id=pseudo-random-number><i id=locator-pseudo-random-number class=header-locator></i>
<a href=#pseudo-random-number class=article-h-a>1 伪随机数(Pseudo-Random Number)</a></h1><p>随机数大家不陌生，但是随机数怎么就和信息安全扯上关系了呢?其实想一想我们在给自己的账号设置密码的时候，是不是都会尽量的让其他人不会轻易的猜到我们的密码，虽然并不是随机，但是它就像是满足了随机数的一个特征 : <strong>不可预测性</strong>。那么对于信息安全来说来说，也是用到了这个特定，当然还有随机数的<strong>随机性</strong>，<strong>不可重复性</strong>这两点特征。</p><ol><li>随机性 : 完全杂乱的序列，没有统计学偏差；</li><li>不可预测性 : 不能由已经得到的随机数才猜测出下一个随机数是什么；</li><li>不可重复性 : 不能生成重复的随机数。</li></ol><p>根据生成的随机数是否满足这3点要求(1&lt;2&lt;3，依次增强)。大致可以划分伪弱伪随机数，强伪随机数，真随机数(强度依次增大)。</p><table><thead><tr><th></th><th>随机性</th><th>不可预测性</th><th>不可重复性</th><th></th></tr></thead><tbody><tr><td>弱伪随机数</td><td>✔</td><td>✘</td><td>✘</td><td>只具备随机性</td></tr><tr><td>强伪随机数</td><td>✔</td><td>✔</td><td>✘</td><td>同时具备不可预测性</td></tr><tr><td>真随机数</td><td>✔</td><td>✔</td><td>✔</td><td>同时具备不可重复性</td></tr></tbody></table><p>仅仅依靠软件我们是无法生成真随机数的，这里我们只关注以下伪随机数(即强伪随机数的生成，可用于密码学安全)的生成，比如一个典型的生成器如下 :<br><img src=./pseudo-random-number-generator.png loading=lazy decoding=auto alt=伪随机数生成器 title=伪随机数生成器></p><p>生成器自己维护一个内部状态，同时接受一个随机数的种子，来生成具体的随机数。具体是实现方式有利用<strong>密码散列函数</strong>(单向性支撑了不可预测性)、利用加密密钥作为随机数的种子的一部分(密钥的机密性支持了不可预测性)等等。</p><p>在C#可以使用的伪随机数生成方式 :</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:green>//1. Random</span>
</span></span><span style=display:flex><span><span style=color:#2b91af>var</span> random = <span style=color:#00f>new</span> Random();
</span></span><span style=display:flex><span><span style=color:#2b91af>var</span> random1 = random.Next(100);
</span></span><span style=display:flex><span>Console.WriteLine(random1);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>//2. Guid </span>
</span></span><span style=display:flex><span><span style=color:#2b91af>var</span> random2 = Guid.NewGuid().ToString(<span style=color:#a31515>&#34;N&#34;</span>);
</span></span><span style=display:flex><span>Console.WriteLine(random2);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>//3. RNGCryptoServiceProvider</span>
</span></span><span style=display:flex><span>RandomNumberGenerator randomNumberGenerator = <span style=color:#00f>new</span> RNGCryptoServiceProvider();
</span></span><span style=display:flex><span><span style=color:#2b91af>var</span> random3Bytes = <span style=color:#00f>new</span> <span style=color:#2b91af>byte</span>[32];
</span></span><span style=display:flex><span>randomNumberGenerator.GetBytes(random3Bytes);
</span></span><span style=display:flex><span><span style=color:#2b91af>var</span> random3 = random3Bytes.ToHexString();
</span></span><span style=display:flex><span>Console.WriteLine(random3);
</span></span></code></pre></div><p>一般情况下，Guid即可满足要求(但是只有固定的16byte)，如需更高强度的伪随机数，可以使用 <code>RNGCryptoServiceProvider</code> 来生成任意长度的随机数。</p><h2 id=practical-use-of-pseudo-random-number><i id=locator-practical-use-of-pseudo-random-number class=header-locator></i>
<a href=#practical-use-of-pseudo-random-number class=article-h-a>1.1 伪随机数的实际应用</a></h2><ol><li>生成密钥 : <a href=../01-cryptography-toolbox-1/#symmetric-cryptography target=_blank rel="noopener norefferrer">对称密码</a>和<a href=../01-cryptography-toolbox-1/#message-authentication-code target=_blank rel="noopener norefferrer">消息认证码</a>；</li><li>生成密钥对 : <a href=../01-cryptography-toolbox-1/#asymmetric-cryptography target=_blank rel="noopener norefferrer">公钥密码</a>和<a href=../01-cryptography-toolbox-1/#digital-signature target=_blank rel="noopener norefferrer">数字签名</a>；</li><li>生成nonce : 防止重放攻击；</li><li>生成salt : 盐用于增强基于口令的密码的加密。</li></ol><h2 id=attack-pseudo-random-number-generator><i id=locator-attack-pseudo-random-number-generator class=header-locator></i>
<a href=#attack-pseudo-random-number-generator class=article-h-a>1.2 针对伪随机数生成器的攻击</a></h2><p>伪随机数的程序结构可以说很简单，但是其中的每个环节都有可能成为被攻击的突破口。</p><ol><li>对种子的攻击 : 如果暴露了种子，那么其实攻击者就可以得到其所有的伪随机数(假设攻击者知道其内部算法的情况下)。</li><li>对伪随机数池的攻击 : 如果我们实现生成了一大堆的伪随机数，用的时候从里面取一个，那么这个存储这些预先生成的伪随机数的地方，就可能会被泄露。</li></ol><h1 id=hybrid-cryptosystem><i id=locator-hybrid-cryptosystem class=header-locator></i>
<a href=#hybrid-cryptosystem class=article-h-a>2 混合密码系统</a></h1><p>针对密码相关的基本工具介绍就暂时可以告一段落了，回顾总结以下有这6个<a href=../01-cryptography-toolbox-1/#symmetric-cryptography target=_blank rel="noopener norefferrer">对称密码</a>,<a href=../01-cryptography-toolbox-1/#asymmetric-cryptography target=_blank rel="noopener norefferrer">公钥密码</a>,<a href=../01-cryptography-toolbox-1/#cryptographic-hash-function target=_blank rel="noopener norefferrer">密码散列函数</a>,<a href=../01-cryptography-toolbox-1/#message-authentication-code target=_blank rel="noopener norefferrer">消息认证码</a>,<a href=../01-cryptography-toolbox-1/#digital-signature target=_blank rel="noopener norefferrer">数字签名</a>,<a href=#pseudo-random-number>伪随机数</a>基本工具，下面我们用这6个基本工具来组合一些高级的工具出来。</p><p>上一篇中介绍到了对称密码(比如AES)和公钥密码(比如RSA)，公钥密码解决了对称密码的密钥配送问题(其实是绕过了)。</p><blockquote><p>复习以下公钥密码的核心流程 : 发送消息这一方先从消息接收方这里请求一个公钥，然后用公钥加密需要发送的信息，接收方使用自己独自持有的私钥来解密信息。</p></blockquote><p>那么如果作为接收方我想要回复发送方的消息怎么办？按照公钥密码的机制，我是不能用自己的私钥加密信息发出去的，因为拥有持有我的公钥的任何人都是可以解密这个信息的。所以，如果仅使用公钥密码，那么就需要通信双方都持有对方的公钥+自己的私钥。这个成本是很高昂的，首先公钥加密解密的速度是会比对称密码加密低2~3个数量级，也就是几百倍的差异；其次双方都面临着针对公钥的认证问题(防止中间人攻击)。</p><p>那么我们可以结合之前提到的一些工具，组合一下，来得到一个性价比高的加密通信方式，即使用以下三个基本工具，组合一个高级点的工具(同时具备对称密码和公钥密码的优点) :</p><ol><li><a href=../01-cryptography-toolbox-1/#symmetric-cryptography target=_blank rel="noopener norefferrer">对称密码</a> : 因为其加密解密的速度比较快，所消耗的资源相对来说比较小，所以用来在通信中承担真正的加密和解密任务。</li><li><a href=../01-cryptography-toolbox-1/#asymmetric-cryptography target=_blank rel="noopener norefferrer">公钥密码</a> : 用来传递对称密码所需的密钥。</li><li><a href=#pseudo-random-number>伪随机数</a> : 用来生成对称密码的密钥。</li></ol><p>看一下混合密码的加密过程 :<br><img src=hybrid-cryptosystem-encryption.png loading=lazy decoding=auto alt=混合密码系统的加密过程 title=混合密码系统的加密过程></p><p>上图是用伪随机数生成器生成一个加密用的会话密钥，来加密明文；同时，把这个会话密钥作为公钥密码中的明文，用公钥加密；然后把这两个密文组合在一起，同时发送给接收方。这里的公钥密钥起到的是一个保证会话密钥机密性的作用，并未直接用来加密真正的明文(又想起来一句话 : 计算机科学的中任何问题，都可以通过添加一个中间层来解决，此言不虚；在另外一个<a href=/authentication-and-authorization target=_blank rel="noopener norefferrer">认证授权</a>系列的博客中，笔者也有这样的体会)。来看以下接收方解密的流程 :<br><img src=hybrid-cryptosystem-decryption.png loading=lazy decoding=auto alt=混合密码系统的解密过程 title=混合密码系统的解密过程></p><p>相对于加密过程来说，是完全反过来的一个过程，就不再解释了。看一段C#中实际使用的代码 :</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#00f>static</span> <span style=color:#00f>void</span> Main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#2b91af>string</span> privateKey;
</span></span><span style=display:flex><span>    <span style=color:#2b91af>string</span> publicKey;
</span></span><span style=display:flex><span>    <span style=color:#00f>using</span> (<span style=color:#2b91af>var</span> asymmetricAlgorithm = RSA.Create())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        privateKey = asymmetricAlgorithm.ToXmlString(<span style=color:#00f>true</span>);
</span></span><span style=display:flex><span>        publicKey = asymmetricAlgorithm.ToXmlString(<span style=color:#00f>false</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:green>// 发送者加密</span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> hybridCiphertext = HybridEncrypt(publicKey, <span style=color:#a31515>&#34;lnh-明文&#34;</span>);
</span></span><span style=display:flex><span>    Console.WriteLine(hybridCiphertext);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>// 接收者解密</span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> plaintext = HybridDecrypt(privateKey, hybridCiphertext);
</span></span><span style=display:flex><span>    Console.WriteLine(plaintext);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Console.ReadKey();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>static</span> <span style=color:#2b91af>string</span> HybridEncrypt(<span style=color:#2b91af>string</span> publicKey, <span style=color:#2b91af>string</span> plaintext)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> plaintextBytes = plaintext.ToBytes(Encoding.UTF8);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>//1. 生成伪随机数，作为会话签名</span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> sessionKey = SecurityHelper.BuildPseudoRandomNumber(16);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>//2. 使用sessionKey作为AES的密钥进行加密</span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> ciphertextBytes = plaintextBytes.AESEncrypt(sessionKey);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>//3. 使用公钥对会话密钥进行加密</span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> sessionkeyCiphertextBytes = sessionKey.RSAEncrypt(publicKey);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>//4. 模拟合成的消息</span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> hybridCiphertext = ciphertextBytes.ToHex() + <span style=color:#a31515>&#34;.&#34;</span> + sessionkeyCiphertextBytes.ToHex();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> hybridCiphertext;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>static</span> <span style=color:#2b91af>string</span> HybridDecrypt(<span style=color:#2b91af>string</span> privateKey, <span style=color:#2b91af>string</span> hybridCiphertext)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green>//1. 分离合成的密文</span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> ciphertext = hybridCiphertext.Split(<span style=color:#a31515>&#39;.&#39;</span>)[0];
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> sessionkeyCiphertext = hybridCiphertext.Split(<span style=color:#a31515>&#39;.&#39;</span>)[1];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> ciphertextBytes = ciphertext.HexToBytes();
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> sessionkeyCiphertextBytes = sessionkeyCiphertext.HexToBytes();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>//2. 用私钥解密得到会话密钥</span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> sessionkey = sessionkeyCiphertextBytes.RSADecrypt(privateKey);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>//3. 用会话密码解密</span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> plaintextBytes = ciphertextBytes.AESDecrypt(sessionkey);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> plaintextBytes.GetString(Encoding.UTF8);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=practical-use-of-hybrid-cryptosystem><i id=locator-practical-use-of-hybrid-cryptosystem class=header-locator></i>
<a href=#practical-use-of-hybrid-cryptosystem class=article-h-a>2.1 混合密码系统的实际应用</a></h2><p>SSL/TLS : 最常见的一个应用场景了，后续会介绍。</p><h2 id=leftover-problem><i id=locator-leftover-problem class=header-locator></i>
<a href=#leftover-problem class=article-h-a>2.2 遗留问题</a></h2><p>混合密码系统只能说是降低了单纯的公钥密码带来的成本问题，而公钥密码遗留的公钥认证问题，在混合密码系统中依然存在。同时使用了伪随机数生成器，混合密码系统也会面临针对伪随机生成器的一些攻击。</p><h1 id=certificate><i id=locator-certificate class=header-locator></i>
<a href=#certificate class=article-h-a>3. 证书(Certificate)- 为公钥添加数字签名</a></h1><p>总结一下<a href=../01-cryptography-toolbox-1/#leftover-problem target=_blank rel="noopener norefferrer">上篇的数字签名遗留的问题</a>和上一小节遗留的问题，汇总在一起的核心就是验证公钥必须是真正的发送者提供的。</p><blockquote><p>数字签名遗留的问题 : 数字签名可以识别出篡改和伪装，还可以防止否认，也就是说数字签名可以提供信息安全中的<strong>完整性</strong>、<strong>认证</strong>和<strong>不可否认性</strong>这3点的保障(很强大有木有)。然而这一切都基于一个假设<strong>公钥必须是真正的发送者提供的</strong>，和公钥密钥陷入了同一个问题。我们发现自己陷入了一个死循环 : <strong>数字签名可以用来识别篡改、伪装以及否认的，但是为此我们又需要从一个没有被伪装的真正的发送者那里得到一个没有被篡改的密钥</strong>。这是一个鸡生蛋蛋生鸡的问题。</p></blockquote><p>所以，想要解决这个问题单靠纯粹的技术手段是行不通了，我们陷入了一个死循环，因此引入了一个社会学中的信任体系来转移我们所面临的问题，即证书以及相关体系结构，提供逐级的信任保障。我们先看看证书是一个什么东西，以及证书的这套相关体系如何提供这种<strong>信任</strong>保障的。</p><p>我们从一出生就会和各种各样的证书打交道，比如出生证，学生证，身份证，驾照，学位证等等，它们都有一个共同点，就是有你本人的真实信息以及开具证明的机构的盖章。那么在需要提供证明你就是你的地方，出具这个证书即可，如果对方不信任你的证书，则可以到开具证书的机构来校验。假如你提供一个假证，而对方没有严格的审查的话，或许你是可以蒙混过关的。</p><p>计算机领域的证书和现实社会中的各种证书的工作原理是完全一样的，因为其工作在计算机体系中，也被称为<strong>数字证书</strong>。计算机中<strong>数字证书</strong>是这样定义的 : <strong>由证书授权中心进行数字签名的，包含公钥以及其拥有者信息的一个文件。注意 : 证书的真正用途在于为公钥提供认证功能，所以有时候也叫做公钥证书。<strong>我们使用这个被称做证书的文件来</strong>转移我们在信息安全层面所面临的死循环的问题</strong>，<strong>为什么说是转移而不是解决呢</strong>，这是因为你拿到一个证书后，也需要进行校验吧，而校验又需要一个真正的发送者提供的公钥才行，那么你就需要另外一个证书来保障，然后你就会一直的循环下去，，，这也是为什么在计算机体系中有根证书的存在，以及相关的证书授权认证中心会是一个层级的关系，这就是为了在你不信任一个证书的时候，可以继续往上一个层级来寻求验证，直到根证书。那么问题就来了，假如你也不相信根证书怎么办？这其实是一个无法回答的问题，笔者想起来之前读《<a href=https://book.douban.com/subject/25985021/ target=_blank rel="noopener norefferrer">人类简史</a>》的时候，有一个至今烙印在脑海中的观点 : <strong>如今的社会，是一个由想象所构建的秩序</strong>。其实想一想，也确实是如此。比如你为何相信国家的存在呢，为何会把钱存进银行呢。你拿出来一张毛爷爷(从物理的角度来看，它就是一张纸而已)为什么就能从饭店买来一堆食物，这其实就是你相信它，对方也相信它，所有人都相信它，背后有银行体系为其担保，那么什么为银行提供担保呢，背后有我们的国家提供保障，这就是一个信任的体系。<strong>计算机体系的数字证书也是基于这么一个共同的想象所构建的信任秩序</strong>。补充一个新闻 : Google 宣布将完全取消对沃通和 StartCom 所有证书的信任(<a href=https://news.cnblogs.com/n/573409/ target=_blank rel="noopener norefferrer">https://news.cnblogs.com/n/573409/</a>)，这就是对方不再信任你的根证书的情况。</p><h2 id=public-key-infrastructure><i id=locator-public-key-infrastructure class=header-locator></i>
<a href=#public-key-infrastructure class=article-h-a>3.1 PKI(Public Key Infrastructure)</a></h2><p>证书得以运行的这个基本的体系称为PKI(Public Key Infrastructure)，即公钥基础设施，它是一套以公钥密码为核心的技术规范标准的一个代名词。总体来说，PKI由3个要素组成 : PKI的消费者；认证机构(<strong>Certificate Authority</strong>，简称CA)；证书仓库。我们常说的CA证书，就是由CA机构签名颁发的证书。CA负责生成密钥对(也可由用户提供)、负责对用户身份进行认证、负责生成并颁发证书、负责作废证书(<a href=https://en.wikipedia.org/wiki/Certificate_revocation_list target=_blank rel="noopener norefferrer">https://en.wikipedia.org/wiki/Certificate_revocation_list</a>)。CA是由层级结构的，正是这个层级结构构建了一套证书的验证链条，其中Root CA的证书是自签名的(也就是自己证明自己)，其下级机构逐层签名，构成一个金字塔似的结构。当然你平时自己也可以生成自签名的证书，但是除了你自己，其他地方是不认可你这个证书的(就好比你拿一张白纸，写上这是100块，然后别人就相信你它值100块吗?)，想要得以正常运行，是需要用户主动确认表示认可你这个证书才行。比如我们用Fiddler抓取HTTPS的内容的时候，其实Fiddler自己生成了一个自签名的根证书，然后你主动的确认信赖它，只有这样，证书构造的这个验证链才能得以正常运行。想起来12306就自己搞了一个自签名的证书，想必大家都有印象吧，，，需要自己下载下来证书，然后导入到计算机中，再确认信任它；其实这也是一个很尴尬的事情，全球最大的几家CA清一色不是美国就是俄罗斯。</p><h2 id=public-key-certificate><i id=locator-public-key-certificate class=header-locator></i>
<a href=#public-key-certificate class=article-h-a>3.2 公钥证书</a></h2><p>好了，分析完数字证书这套体系为什么能够运转起来为我们提供公钥的认证的保障之后。看看计算机中的公钥证书是什么样的，我们拿<a href=https://www.google.com/ncr target=_blank rel="noopener norefferrer">https://www.google.com</a>的做例子(F12，打开安全选项卡即可)，证书的相关信息如下 :<br><img src=google-public-key-certificate-1.png loading=lazy decoding=auto alt title><br><img src=google-public-key-certificate-2.png loading=lazy decoding=auto alt title><br><img src=google-public-key-certificate-3.png loading=lazy decoding=auto alt title></p><p>证书除了包含公钥、签名算法和证书的层级结构(比如google这个的顶级颁发机构是GeoTurst Global CA)，还有一些证书的序号，版本信息，有效时间等等。这些信息由一个证书数据格式的标准规范来规定的，一个很通用的格式是<a href=../05-x.509/ target=_blank rel="noopener norefferrer">X509</a>，感兴趣的可以了解一下，这里就不介绍了。C#中有很多X509相关的类可以供我们使用。比如来读取一下上述google的这个证书信息(我把证书导出为了base64格式的数据，可以方便的直接包含在代码中) :</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#00f>private</span> <span style=color:#00f>static</span> <span style=color:#00f>readonly</span> <span style=color:#2b91af>string</span> GoogleBase64FormatPublicKeyCertificate = <span style=color:#a31515>@&#34;
</span></span></span><span style=display:flex><span><span style=color:#a31515>-----BEGIN CERTIFICATE-----
</span></span></span><span style=display:flex><span><span style=color:#a31515>MIIEgDCCA2igAwIBAgIIaCtCibL6TxQwDQYJKoZIhvcNAQELBQAwSTELMAkGA1UE
</span></span></span><span style=display:flex><span><span style=color:#a31515>BhMCVVMxEzARBgNVBAoTCkdvb2dsZSBJbmMxJTAjBgNVBAMTHEdvb2dsZSBJbnRl
</span></span></span><span style=display:flex><span><span style=color:#a31515>cm5ldCBBdXRob3JpdHkgRzIwHhcNMTcwNjIxMTQzNTUwWhcNMTcwOTEzMTM1MzAw
</span></span></span><span style=display:flex><span><span style=color:#a31515>WjBoMQswCQYDVQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwN
</span></span></span><span style=display:flex><span><span style=color:#a31515>TW91bnRhaW4gVmlldzETMBEGA1UECgwKR29vZ2xlIEluYzEXMBUGA1UEAwwOd3d3
</span></span></span><span style=display:flex><span><span style=color:#a31515>Lmdvb2dsZS5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDFHtwc
</span></span></span><span style=display:flex><span><span style=color:#a31515>1ECzMNuXPshUwS9IkyKPuHYA6WXa3ohXW/wMHo0IKnu5WgXmduLS6cGoFlT3oq3P
</span></span></span><span style=display:flex><span><span style=color:#a31515>PXJz11gKpdBJeoLs/g4lG3mOnGRSQbjtsWsXCPsunMjeq0vTfidJ2Gt+1eMHh5B4
</span></span></span><span style=display:flex><span><span style=color:#a31515>qcgOxbXEK9AE6GZGCL3MSV2lE2oG0GDpStZkLhKt11GE+qrLSQCpH9XgzknHdrvz
</span></span></span><span style=display:flex><span><span style=color:#a31515>OU6Kl3e5W+4QO6rTq5285D18Ep6Cugf39JbZQZHSu0ejLnmtSOHwUg1i/vbJrDN/
</span></span></span><span style=display:flex><span><span style=color:#a31515>yVwEySn+drxv0CzPDrTMiqGLVxBOSwN9wU9cRphiLLSdE4Sy2p77jCNLWzbcQQ5P
</span></span></span><span style=display:flex><span><span style=color:#a31515>5f+2hLXb2Z/N1kAZAgMBAAGjggFLMIIBRzAdBgNVHSUEFjAUBggrBgEFBQcDAQYI
</span></span></span><span style=display:flex><span><span style=color:#a31515>KwYBBQUHAwIwGQYDVR0RBBIwEIIOd3d3Lmdvb2dsZS5jb20waAYIKwYBBQUHAQEE
</span></span></span><span style=display:flex><span><span style=color:#a31515>XDBaMCsGCCsGAQUFBzAChh9odHRwOi8vcGtpLmdvb2dsZS5jb20vR0lBRzIuY3J0
</span></span></span><span style=display:flex><span><span style=color:#a31515>MCsGCCsGAQUFBzABhh9odHRwOi8vY2xpZW50czEuZ29vZ2xlLmNvbS9vY3NwMB0G
</span></span></span><span style=display:flex><span><span style=color:#a31515>A1UdDgQWBBTxnCXke+dTXQNZyBd5gWpjj8kdKjAMBgNVHRMBAf8EAjAAMB8GA1Ud
</span></span></span><span style=display:flex><span><span style=color:#a31515>IwQYMBaAFErdBhYbvPZotXb1gba7Yhq6WoEvMCEGA1UdIAQaMBgwDAYKKwYBBAHW
</span></span></span><span style=display:flex><span><span style=color:#a31515>eQIFATAIBgZngQwBAgIwMAYDVR0fBCkwJzAloCOgIYYfaHR0cDovL3BraS5nb29n
</span></span></span><span style=display:flex><span><span style=color:#a31515>bGUuY29tL0dJQUcyLmNybDANBgkqhkiG9w0BAQsFAAOCAQEAgHtFBvVyIQwRSrUC
</span></span></span><span style=display:flex><span><span style=color:#a31515>RbPu0fZFl9HJCJ0FBXVlQl0JO5PdRTtXlkfDqeoZcE3l562/FotKyaPKRyhktYDb
</span></span></span><span style=display:flex><span><span style=color:#a31515>5tnYo74q1gKxfmTjXEtkBeUDUAlNzepuXYudu43A5athR/GPIDxXQvQc4Lakmafi
</span></span></span><span style=display:flex><span><span style=color:#a31515>LJFTZLw7ZjmkU0mkt3uaiUXTuOiA+5hjjGLzFzRpRXvUcqIggGUTVJ4v7HSmOl3x
</span></span></span><span style=display:flex><span><span style=color:#a31515>tjePNc8ps3bivp8WtB4jR6k+PvVmlYDN/Uf7+cwmOEtrXUBCrVwA/LL+j3mkwHK0
</span></span></span><span style=display:flex><span><span style=color:#a31515>49h5xyjmB/ndmH/HgjY2DSzu2HMekkPJEnPWmkxqRP2c08UqQoUbXE9zdL35Ys5A
</span></span></span><span style=display:flex><span><span style=color:#a31515>JRO+1w==
</span></span></span><span style=display:flex><span><span style=color:#a31515>-----END CERTIFICATE-----
</span></span></span><span style=display:flex><span><span style=color:#a31515>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>static</span> <span style=color:#00f>void</span> Main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> bytes = GoogleBase64FormatPublicKeyCertificate.ToBytes(Encoding.ASCII);
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> x509 = <span style=color:#00f>new</span> X509Certificate2(bytes);
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> text = x509.ToString(<span style=color:#00f>true</span>);
</span></span><span style=display:flex><span>    Console.WriteLine(text);
</span></span><span style=display:flex><span>    Console.ReadKey();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=public-key-cryptography-standards><i id=locator-public-key-cryptography-standards class=header-locator></i>
<a href=#public-key-cryptography-standards class=article-h-a>3.3 PKCS(Public Key Cryptography Standards)</a></h2><p>证书的相关格式以及交换标准在PKCS(<a href=https://en.wikipedia.org/wiki/PKCS target=_blank rel="noopener norefferrer">Public-Key Cryptography Standards</a>)中有详细的定义。常见的证书编码格式 :</p><ol><li><code>PEM</code> : Privacy Enhanced Mail，以"-----BEGIN..."开头,以 "-----END..."结尾，中间内容是base64编码的文本。</li><li><code>DER</code> : Distinguished Encoding Rules，二进制格式。</li></ol><p>常见到的几个证书扩展名 :</p><ol><li><code>.p7b</code> : 特点是其包含相关其证书链，不含私钥。</li><li><code>.cer</code> / <code>.crt</code> : 一般是采用DER编码的二进制格式，不含私钥。</li><li><code>.pem</code> : 一般是采用PEM编码的base64格式，不含私钥，另外其文件一般采用ASCII编码。</li><li><code>.pfx</code> / <code>.p12</code> : 一般是采用DER编码的二进制格式，包含公钥和私钥的。</li></ol><h1 id=summary><i id=locator-summary class=header-locator></i>
<a href=#summary class=article-h-a>4. 总结</a></h1><p>本篇完善了密码相关的工具箱，增加了伪随机数，混合密码系统，以及通过转移问题而解决公钥的认证问题的数字证书，以及数字证书的工作机制，和其相关的一些细节点(当然都是一笔带过了，想了解更详细的信息还需读者自行研究)。本系列后续的会拿这个工具箱来剖析HTTPS是如何工作的。如有错误指出，欢迎指正！</p><h1 id=reference><i id=locator-reference class=header-locator></i>
<a href=#reference class=article-h-a>5 参考资料</a></h1><p>伪随机数生成器 : <a href=https://en.wikipedia.org/wiki/Random_number_generation target=_blank rel="noopener norefferrer">https://en.wikipedia.org/wiki/Random_number_generation</a></p><p>公钥证书 : <a href=https://en.wikipedia.org/wiki/Public_key_certificate target=_blank rel="noopener norefferrer">https://en.wikipedia.org/wiki/Public_key_certificate</a></p><p>CRL(Certificate revocation list) : <a href=https://en.wikipedia.org/wiki/Certificate_revocation_list target=_blank rel="noopener norefferrer">https://en.wikipedia.org/wiki/Certificate_revocation_list</a></p><p>Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile : <a href=https://tools.ietf.org/html/rfc5280 target=_blank rel="noopener norefferrer">https://tools.ietf.org/html/rfc5280</a></p><p>PKCS : <a href=https://en.wikipedia.org/wiki/PKCS target=_blank rel="noopener norefferrer">https://en.wikipedia.org/wiki/PKCS</a></p><p>X.509 : <a href=https://en.wikipedia.org/wiki/X.509 target=_blank rel="noopener norefferrer">https://en.wikipedia.org/wiki/X.509</a></p></section><section class=article-meta><section class=article-date>2017-07-02 15:08，约5006字，阅读约10分钟</section><section class=article-topics><a class=article-topic href=/information-security/ title=[信息安全] target=_blank><i class="fa fa-folder"></i>[信息安全]</a></section><section class=article-tags><a class=article-tag href=/tag/cer target=_blank><i class="fa fa-tag"></i>cer</a>
<a class=article-tag href=/tag/p12 target=_blank><i class="fa fa-tag"></i>p12</a>
<a class=article-tag href=/tag/pem target=_blank><i class="fa fa-tag"></i>pem</a>
<a class=article-tag href=/tag/pfx target=_blank><i class="fa fa-tag"></i>pfx</a>
<a class=article-tag href=/tag/pki target=_blank><i class="fa fa-tag"></i>PKI</a>
<a class=article-tag href=/tag/%E6%B7%B7%E5%90%88%E5%AF%86%E7%A0%81 target=_blank><i class="fa fa-tag"></i>混合密码</a>
<a class=article-tag href=/tag/%E8%AF%81%E4%B9%A6 target=_blank><i class="fa fa-tag"></i>证书</a>
<a class=article-tag href=/tag/%E9%9A%8F%E6%9C%BA%E6%95%B0 target=_blank><i class="fa fa-tag"></i>随机数</a></section><section class=article-git><a class=article-git-commit href=https://github.com/linianhui/blog/commit/e8a5d272eaab71031c97f4d679e7edceafa475ea target=_blank><i class="fa fa-code-fork"></i>e8a5d27</a>
<span class=article-git-commit-subject>fix markdown</span>
<span class=article-git-commit-time>2023-12-08 07:09</span>
<a class=article-git-source href=https://github.com/linianhui/blog/blob/main/src/information-security/02-cryptography-toolbox-2/index.md target=_blank><i class="fa fa-github"></i>源码</a></section></section><section class=article-page><div class=article-page-prev><span>上一篇 : </span><a href=/information-security/01-cryptography-toolbox-1/ target=_blank>[信息安全] 01 密码工具箱 第1部分</a></div><div class=article-page-next><span>下一篇 : </span><a href=/information-security/03-https/ target=_blank>[信息安全] 03 HTTPS工作流程</a></div></section></article><section id=article-comment class=article-comment><script src=https://utteranc.es/client.js repo=linianhui/blog issue-term=pathname label=blog-comment theme=github-light crossorigin=anonymous async></script></section></main><footer class=footer><section>Copyright © 2025 by <a href=https://github.com/linianhui/blog target=_blank>Timetombs</a></section><section><a class=article-git-commit href=https://github.com/linianhui/blog/commit/2fac07e818d6d4ad6b78781efea82c28769c8c02 target=_blank><i class="fa fa-code-fork"></i>2fac07e</a>
Powered by
<a href=https://github.com/actions target=_blank>GitHub Actions</a>
,
<a href=https://github.com/gohugoio/hugo target=_blank>Hugo</a>
and
<a href=https://github.com/utterance/utterances target=_blank>utterances</a>
Hosted on <a href=https://pages.github.com/ target=_blank>GitHub Pages</a><section></footer></main><aside class=toolbar><a class="fa fa-list" href=javascript:blog.toggleToc(); title=目录></a><a class="fa fa-comments" href=#article-comment title=评论></a><a class="fa fa-arrow-up" href=javascript:scroll(0,0); title=返回顶部></a></aside><script type=text/javascript>var _hmt=_hmt||[];blog.addOnScorllEvent()</script><script src=https://hm.baidu.com/hm.js?b2cc3cea316e1f7a8def1bab8dc98fad async></script></body></html>