<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=google-site-verification content="X6gTMGCy1-_vb5i3aja3ZZyzPY3raiKRJp4VIhOAX24"><meta name=msvalidate.01 content="CDE7502649B75529BD0FCFE89B056E38"><title>[信息安全] 04 一次性密码 & 身份认证 - Timetombs</title>
<link rel=icon type=image/svg href=/favicon.svg><link rel=stylesheet href=https://s4.zstatic.net/ajax/libs/normalize/8.0.1/normalize.min.css crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://s4.zstatic.net/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css crossorigin=anonymous referrerpolicy=no-referrer><link href='/asset/blog.css?time=2025-10-26T19%3a03%3a29Z%2b08%3a00' rel=stylesheet type=text/css><script src=https://s4.zstatic.net/npm/currency.js@2.0.4/dist/currency.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://s4.zstatic.net/ajax/libs/moment.js/2.30.1/moment.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src='/asset/blog.js?time=2025-10-26T19%3a03%3a29Z%2b08%3a00' type=application/javascript></script><script type=text/javascript>blog.isMobile()&&document.write('<link href="/asset/blog.mobile.css?time=2025-10-26T19%3A03%3A29Z%2B08%3A00" rel="stylesheet">')</script></head><body><div id=horizontal-progress class=horizontal-progress></div><aside id=toc class=toc><section class=toc-header><a class=toc-page-title href=/information-security/ target=_blank>[信息安全]</a></section><section class=toc-page><a class=toc-page-title href=/information-security/01-cryptography-toolbox-1/ target=_blank>[信息安全] 01 密码工具箱 第1部分</a></section><section class=toc-page><a class=toc-page-title href=/information-security/02-cryptography-toolbox-2/ target=_blank>[信息安全] 02 密码工具箱 第2部分</a></section><section class=toc-page><a class=toc-page-title href=/information-security/03-https/ target=_blank>[信息安全] 03 HTTPS工作流程</a></section><section class="toc-page selected"><span class=toc-page-title>[信息安全] 04 一次性密码 & 身份认证</span><nav id=TableOfContents><ul><li><a href=#one-time-password>1 OTP 一次性密码</a></li><li><a href=#hmac-based-one-time-password>2. HOTP 基于消息认证码的一次性密码</a></li><li><a href=#time-based-one-time-password>3 TOTP 基于时间的一次性密码</a></li><li><a href=#identity-authentication>4 身份认证</a><ul><li><a href=#two-steps-verification>4.1 2SV 两步验证(Two Steps Verification)</a></li><li><a href=#two-factor-authentication>4.2 2FA 双因素认证(Two Factor Authentication)</a></li></ul></li><li><a href=#summary>5 总结</a></li><li><a href=#reference>6 参考资料</a><ul><li><a href=#example>6.1 示例</a></li></ul></li></ul></nav></section><section class=toc-page><a class=toc-page-title href=/information-security/05-x.509/ target=_blank>[信息安全] 05 X.509 公钥证书的格式标准</a></section><script type=text/javascript>blog.isPC()&&blog.toggleToc()</script></aside><main class=main><header class=header><hgroup class=header-hgroup><h1 class=header-hgroup-title><a href=/>Timetombs</a></h1><h2 class=header-hgroup-subtitle>泛义的工具是文明的基础，而确指的工具却是愚人的器物</h2></hgroup><nav class=header-nav><a class=header-nav-item href=/topic/ title=专题 target=_self><i class="fa fa-folder"></i>专题</a>
<a class=header-nav-item href=/tag/ title=标签 target=_self><i class="fa fa-tags"></i>标签</a>
<a class=header-nav-item href=/archive/ title=归档 target=_self><i class="fa fa-archive"></i>归档</a>
<a class=header-nav-item href=https://linianhui.cnblogs.com title=博客园 target=_black><img src=/asset/cnblogs.favicon.svg>博客园</a>
<a class=header-nav-item href=https://github.com/linianhui/blog title=GitHub target=_black><i class="fa fa-github"></i>GitHub</a></nav><div class=header-stats><div class=stats><span>共
<i>66<sub>h</sub>
</i>/
<i>118<sub>a</sub>
</i>篇</span><div class=stats-date>，更新于 2025-10-26T19:03:29Z+08:00 by &nbsp;
<a class=git-commit href=https://github.com/linianhui/blog/commit/2fac07e818d6d4ad6b78781efea82c28769c8c02 target=_blank><i class="fa fa-code-fork"></i>2fac07e</a></div></div><form class=search method=GET target=_blank action=https://www.bing.com/search><input name=q class=search-input type=search placeholder=search... results=5 onkeypress="search_param.value=search_param_site.value+this.value">
<input id=search_param_site type=hidden value="site:linianhui.github.io ">
<input name=q id=search_param type=hidden></form></div></header><main class=content><article class=article><h1 class=article-title>[信息安全] 04 一次性密码 & 身份认证</h1><div class=article-copyright><span>版权声明 - </span><a href=/copyright/cc target=_blank>CC BY-NC-SA 4.0</a></div><section class=article-meta><section class=article-date>2017-07-23 14:24，约2464字，阅读约5分钟</section><section class=article-topics><a class=article-topic href=/information-security/ title=[信息安全] target=_blank><i class="fa fa-folder"></i>[信息安全]</a></section><section class=article-tags><a class=article-tag href=/tag/2fa target=_blank><i class="fa fa-tag"></i>2FA</a>
<a class=article-tag href=/tag/2sv target=_blank><i class="fa fa-tag"></i>2SV</a>
<a class=article-tag href=/tag/hotp target=_blank><i class="fa fa-tag"></i>HOTP</a>
<a class=article-tag href=/tag/mfa target=_blank><i class="fa fa-tag"></i>MFA</a>
<a class=article-tag href=/tag/otp target=_blank><i class="fa fa-tag"></i>OTP</a>
<a class=article-tag href=/tag/totp target=_blank><i class="fa fa-tag"></i>TOTP</a></section><section class=article-git><a class=article-git-commit href=https://github.com/linianhui/blog/commit/03e0cc08866458647d96951c1817c624518149d6 target=_blank><i class="fa fa-code-fork"></i>03e0cc0</a>
<span class=article-git-commit-subject>fix add displayed_on_home</span>
<span class=article-git-commit-time>2022-11-20 14:49</span>
<a class=article-git-source href=https://github.com/linianhui/blog/blob/main/src/information-security/04-one-time-password/index.md target=_blank><i class="fa fa-github"></i>源码</a></section></section><section class=article-content><p>在信息安全领域，一般把<strong>Cryptography</strong>称为<strong>密码</strong>，而把<strong>Password</strong>称为<strong>口令</strong>。日常用户的认知中，以及我们开发人员沟通过程中，绝大多数被称作密码的东西其实都是Password(口令)，而不是真正意义上的密码。本文保持这种语义，采用密码来代指Password，而当密码和口令同时出现时，用英文表示以示区分。</p><h1 id=one-time-password><i id=locator-one-time-password class=header-locator></i>
<a href=#one-time-password class=article-h-a>1 OTP 一次性密码</a></h1><p>OTP是One Time Password的简写，即一次性密码。在平时生活中，我们接触一次性密码的场景非常多，比如在登录账号、找回密码，更改密码和转账操作等等这些场景，其中一些常用到的方式有 :</p><ol><li>手机短信+短信验证码；</li><li>邮件+邮件验证码；</li><li>认证器软件+验证码，比如Microsoft Authenticator App，Google Authenticator App等等；</li><li>硬件+验证码 : 比如网银的电子密码器；</li></ol><p>这些场景的流程一般都是在用户提供了账号+密码的基础上，让用户再提供一个一次性的验证码来提供一层额外的安全防护。通常情况下，这个验证码是一个6-8位的数字，只能使用一次或者仅在很短的时间内可用(比如5分钟以内)。</p><h1 id=hmac-based-one-time-password><i id=locator-hmac-based-one-time-password class=header-locator></i>
<a href=#hmac-based-one-time-password class=article-h-a>2. HOTP 基于消息认证码的一次性密码</a></h1><p>HOTP是HMAC-Based One Time Password的缩写，即是基于HMAC(基于Hash的<a href=../01-cryptography-toolbox-1/#message-authentication-code target=_blank rel="noopener norefferrer">消息认证码</a>)实现的一次性密码。算法细节定义在RFC4226(<a href=https://tools.ietf.org/html/rfc4226 target=_blank rel="noopener norefferrer">https://tools.ietf.org/html/rfc4226</a>)，算法公式为 : <code>HOTP(Key,Counter)</code>，拆开是<code>Truncate(HMAC-SHA-1(Key,Counter))</code> 。</p><ol><li>Key : 密钥；</li><li>Counter : 一个计数器；</li><li>HMAC-SHA-1 : 基于SHA1的HMAC算法的一个函数，返回MAC的值，MAC是一个20bytes(160bits)的字节数组；</li><li>Truncate : 一个截取数字的函数，以3中的MAC为参数，按照指定规则，得到一个6位或者8位数字(位数太多的话不方便用户输入，太少的话又容易被暴力猜测到)；</li></ol><p>C#实现基于HMAC的OTP的代码 :</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>static</span> <span style=color:#2b91af>string</span> HOTP(<span style=color:#2b91af>byte</span>[] key, <span style=color:#2b91af>byte</span>[] counter, <span style=color:#2b91af>int</span> length = 6)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> hmac = counter.ToHMACSHA1(key);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> offset = hmac[hmac.Length - 1] &amp; 0xF;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> b1 = (hmac[offset] &amp; 0x7F) &lt;&lt; 24;
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> b2 = (hmac[offset + 1] &amp; 0xFF) &lt;&lt; 16;
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> b3 = (hmac[offset + 2] &amp; 0xFF) &lt;&lt; 8;
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> b4 = (hmac[offset + 3] &amp; 0xFF);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> code = b1 | b2 | b3 | b4;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> <span style=color:#00f>value</span> = code % (<span style=color:#2b91af>int</span>)Math.Pow(10, length);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> <span style=color:#00f>value</span>.ToString().PadLeft(length, <span style=color:#a31515>&#39;0&#39;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>调用一下试试看 :</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:green>//密钥key</span>
</span></span><span style=display:flex><span><span style=color:#2b91af>var</span> key = <span style=color:#a31515>&#34;lnh_key&#34;</span>.ToBytes(Encoding.UTF8);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>//计数器</span>
</span></span><span style=display:flex><span><span style=color:#2b91af>var</span> counter = <span style=color:#a31515>&#34;lnh_counter&#34;</span>.ToBytes(Encoding.UTF8);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>//otp6=752378</span>
</span></span><span style=display:flex><span><span style=color:#2b91af>var</span> otp6 = SecurityHelper.HOTP(key, counter,6);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>//otp8=49752378</span>
</span></span><span style=display:flex><span><span style=color:#2b91af>var</span> otp8 = SecurityHelper.HOTP(key, counter, 8);
</span></span></code></pre></div><p>其中key是HOTP算法需要的一个密钥(不可泄露)；counter是每次生成HOTP的时候使用的计数器，使用一次就更换一个。然后就可以用来生成OTP了，第一此截取了6位，第二此截取了8位。</p><h1 id=time-based-one-time-password><i id=locator-time-based-one-time-password class=header-locator></i>
<a href=#time-based-one-time-password class=article-h-a>3 TOTP 基于时间的一次性密码</a></h1><p>TOTP是Time-Based One Time Password的缩写。TOTP是在HOTP的基础上扩展的一个算法，算法细节定义在RFC6238(<a href=https://tools.ietf.org/html/rfc6238 target=_blank rel="noopener norefferrer">https://tools.ietf.org/html/rfc6238</a>)，其核心在于把HOTP中的counter换成了时间T，可以简单的理解为一个当前时间的时间戳(unixtime)。一般实际应用中会固定一个时间的步长，比如30秒，60秒，120秒等等，也就是说再这个步长的时间内，基于TOTP算法算出的OTP值是一样的。废话不多说，看看TOTP算法的核心代码 :</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>static</span> <span style=color:#2b91af>string</span> TOTP(<span style=color:#2b91af>byte</span>[] key, <span style=color:#2b91af>int</span> step = 60, <span style=color:#2b91af>int</span> length = 6)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> unixTime = (DateTime.UtcNow - <span style=color:#00f>new</span> DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds;
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> counter = ((<span style=color:#2b91af>int</span>)unixTime) / step;
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> counterBytes = BitConverter.GetBytes(counter);
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> HOTP(key, counterBytes, length);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>调用一下试试看 :</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:green>//密钥key</span>
</span></span><span style=display:flex><span><span style=color:#2b91af>var</span> key = <span style=color:#a31515>&#34;lnh_key&#34;</span>.ToBytes(Encoding.UTF8);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>//在10秒内生成，otp是一样的</span>
</span></span><span style=display:flex><span><span style=color:#00f>for</span> (<span style=color:#2b91af>var</span> i = 0; i &lt; 100; i++)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> otp = SecurityHelper.TOTP(key, 10, 6);
</span></span><span style=display:flex><span>    Console.WriteLine(otp);
</span></span><span style=display:flex><span>    Thread.Sleep(1000);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><img src=totp-result.png loading=lazy decoding=auto alt=基于时间的一次性密码 title=基于时间的一次性密码><h1 id=identity-authentication><i id=locator-identity-authentication class=header-locator></i>
<a href=#identity-authentication class=article-h-a>4 身份认证</a></h1><p>首先解释下什么是身份认证？其实很简单，就是让对方相信你就是你。那么如何让对方相信你就是你呢？按照你能提供的信息的等级来划分，大致有如下三种信息可以证明你就是你自己 :</p><ol><li>你所<code>知道</code>的信息 : 比如我们最广泛使用的<strong>用户名+密码</strong>，因为只有你自己知道<strong>用户名+密码</strong>这个信息组合，那么当你把这个组合提供给我的时候，我就可以相信你就是你。</li><li>你所<code>拥有</code>的信息 : 假如你的<strong>用户名+密码</strong>泄露给了第三方，这个时候你就会有被第三方冒充的危险了。怎么办呢，再进一步提供一个只有<strong>你自己拥有的信息</strong>，即可防止被第三方冒充的危险。</li><li>你所<code>独有</code>的信息 : 再假设一下，你拥有的信息也被泄露给了第三方，这个时候你又会面临被冒充的危险。再进一步，提供一个只有<strong>你自己所独有的的信息</strong>，比如你的指纹，虹膜，面部特征等等。</li></ol><h2 id=two-steps-verification><i id=locator-two-steps-verification class=header-locator></i>
<a href=#two-steps-verification class=article-h-a>4.1 2SV 两步验证(Two Steps Verification)</a></h2><p>两步验证现在是一个再加强认证安全方面广泛使用的一个解决方案。比如Google的2SV(<a href=https://www.google.com/landing/2step/ target=_blank rel="noopener norefferrer">https://www.google.com/landing/2step/</a>)，Microsoft的2SV(<a href=https://support.microsoft.com/zh-cn/help/12408/microsoft-account-about-two-step-verification target=_blank rel="noopener norefferrer">https://support.microsoft.com/zh-cn/help/12408/microsoft-account-about-two-step-verification</a>)等等，通常的做法是当用户输入了<strong>用户名+密码</strong>的基础上，会让用户再提供一个<strong>一次性密码</strong>(以短信、邮件，或者动态密码生成器app的方式发放给用户)。再有比如在一些服务中需要用户额外设置的安全问题，比如**你的出生地在哪？**等等此类。</p><h2 id=two-factor-authentication><i id=locator-two-factor-authentication class=header-locator></i>
<a href=#two-factor-authentication class=article-h-a>4.2 2FA 双因素认证(Two Factor Authentication)</a></h2><p>2SV有个孪生兄弟2FA(双因素认证 : Two Factor Authentication)，那么关于2SV和2FA有什么区别呢，比如让用户在<strong>用户名+密码</strong>的基础上提供的额外的<strong>一次性密码</strong>，关于这个<strong>一次性密码</strong>到底是属于<strong>你所知道的信息</strong>还是<strong>你所拥有的信息</strong>呢？并没有明显的区分界限，有兴趣的可以看看这里的讨论 :<a href=https://security.stackexchange.com/questions/41939/two-step-vs-two-factor-authentication-is-there-a-difference target=_blank rel="noopener norefferrer">https://security.stackexchange.com/questions/41939/two-step-vs-two-factor-authentication-is-there-a-difference</a>。 如果你觉得这个一次性密码属于<strong>你所知道的信息</strong>，那么你可以认为它是2SV；如果你觉得这个一次性密码属于<strong>你所拥有的信息</strong>，那么你可以认为它是2FA。</p><p>总结来说，2FA就是使用了身份认证中的2个要素。</p><h1 id=summary><i id=locator-summary class=header-locator></i>
<a href=#summary class=article-h-a>5 总结</a></h1><p>简单的介绍了下一次性密码的原理以及其应用场景。如有错误之处，欢迎指正！</p><h1 id=reference><i id=locator-reference class=header-locator></i>
<a href=#reference class=article-h-a>6 参考资料</a></h1><p>OTP(One Time Password)Wiki : <a href=https://en.wikipedia.org/wiki/One-time_password target=_blank rel="noopener norefferrer">https://en.wikipedia.org/wiki/One-time_password</a></p><p>One Time Password System : <a href=https://tools.ietf.org/html/rfc2289 target=_blank rel="noopener norefferrer">https://tools.ietf.org/html/rfc2289</a></p><p>HOTP(HMAC-Based One Time Password) Wiki : <a href=https://en.wikipedia.org/wiki/HMAC-based_One-time_Password_Algorithm target=_blank rel="noopener norefferrer">https://en.wikipedia.org/wiki/HMAC-based_One-time_Password_Algorithm</a></p><p>HOTP(HMAC-Based One Time Password)RFC : <a href=https://tools.ietf.org/html/rfc4226 target=_blank rel="noopener norefferrer">https://tools.ietf.org/html/rfc4226</a></p><p>TOTP(Time-Based One Time Password)Wiki : <a href=https://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm target=_blank rel="noopener norefferrer">https://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm</a></p><p>TOTP(Time-Based One Time Password)RFC : <a href=https://tools.ietf.org/html/rfc6238 target=_blank rel="noopener norefferrer">https://tools.ietf.org/html/rfc6238</a></p><p>2SV vs 2FA (1) : <a href=https://security.stackexchange.com/questions/41939/two-step-vs-two-factor-authentication-is-there-a-difference target=_blank rel="noopener norefferrer">https://security.stackexchange.com/questions/41939/two-step-vs-two-factor-authentication-is-there-a-difference</a></p><p>2SV vs 2FA (2) : <a href=https://paul.reviews/the-difference-between-two-factor-and-two-step-authentication/ target=_blank rel="noopener norefferrer">https://paul.reviews/the-difference-between-two-factor-and-two-step-authentication/</a></p><p>MFA/2FA(Multi Factor Authentication) Wiki : <a href=https://en.wikipedia.org/wiki/Multi-factor_authentication target=_blank rel="noopener norefferrer">https://en.wikipedia.org/wiki/Multi-factor_authentication</a></p><h2 id=example><i id=locator-example class=header-locator></i>
<a href=#example class=article-h-a>6.1 示例</a></h2><p>Google Authenticator : <a href=https://github.com/google/google-authenticator/wiki target=_blank rel="noopener norefferrer">https://github.com/google/google-authenticator/wiki</a></p><p>Example: <a href=https://authenticator.ppl.family/ target=_blank rel="noopener norefferrer">https://authenticator.ppl.family/</a></p></section><section class=article-meta><section class=article-date>2017-07-23 14:24，约2464字，阅读约5分钟</section><section class=article-topics><a class=article-topic href=/information-security/ title=[信息安全] target=_blank><i class="fa fa-folder"></i>[信息安全]</a></section><section class=article-tags><a class=article-tag href=/tag/2fa target=_blank><i class="fa fa-tag"></i>2FA</a>
<a class=article-tag href=/tag/2sv target=_blank><i class="fa fa-tag"></i>2SV</a>
<a class=article-tag href=/tag/hotp target=_blank><i class="fa fa-tag"></i>HOTP</a>
<a class=article-tag href=/tag/mfa target=_blank><i class="fa fa-tag"></i>MFA</a>
<a class=article-tag href=/tag/otp target=_blank><i class="fa fa-tag"></i>OTP</a>
<a class=article-tag href=/tag/totp target=_blank><i class="fa fa-tag"></i>TOTP</a></section><section class=article-git><a class=article-git-commit href=https://github.com/linianhui/blog/commit/03e0cc08866458647d96951c1817c624518149d6 target=_blank><i class="fa fa-code-fork"></i>03e0cc0</a>
<span class=article-git-commit-subject>fix add displayed_on_home</span>
<span class=article-git-commit-time>2022-11-20 14:49</span>
<a class=article-git-source href=https://github.com/linianhui/blog/blob/main/src/information-security/04-one-time-password/index.md target=_blank><i class="fa fa-github"></i>源码</a></section></section><section class=article-page><div class=article-page-prev><span>上一篇 : </span><a href=/information-security/03-https/ target=_blank>[信息安全] 03 HTTPS工作流程</a></div><div class=article-page-next><span>下一篇 : </span><a href=/information-security/05-x.509/ target=_blank>[信息安全] 05 X.509 公钥证书的格式标准</a></div></section></article><section id=article-comment class=article-comment><script src=https://utteranc.es/client.js repo=linianhui/blog issue-term=pathname label=blog-comment theme=github-light crossorigin=anonymous async></script></section></main><footer class=footer><section>Copyright © 2025 by <a href=https://github.com/linianhui/blog target=_blank>Timetombs</a></section><section><a class=article-git-commit href=https://github.com/linianhui/blog/commit/2fac07e818d6d4ad6b78781efea82c28769c8c02 target=_blank><i class="fa fa-code-fork"></i>2fac07e</a>
Powered by
<a href=https://github.com/actions target=_blank>GitHub Actions</a>
,
<a href=https://github.com/gohugoio/hugo target=_blank>Hugo</a>
and
<a href=https://github.com/utterance/utterances target=_blank>utterances</a>
Hosted on <a href=https://pages.github.com/ target=_blank>GitHub Pages</a><section></footer></main><aside class=toolbar><a class="fa fa-list" href=javascript:blog.toggleToc(); title=目录></a><a class="fa fa-comments" href=#article-comment title=评论></a><a class="fa fa-arrow-up" href=javascript:scroll(0,0); title=返回顶部></a></aside><script type=text/javascript>var _hmt=_hmt||[];blog.addOnScorllEvent()</script><script src=https://hm.baidu.com/hm.js?b2cc3cea316e1f7a8def1bab8dc98fad async></script></body></html>