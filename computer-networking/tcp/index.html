<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=google-site-verification content="X6gTMGCy1-_vb5i3aja3ZZyzPY3raiKRJp4VIhOAX24"><meta name=msvalidate.01 content="CDE7502649B75529BD0FCFE89B056E38"><title>[计算机网络] TCP - Timetombs</title>
<link rel=icon type=image/svg href=/favicon.svg><link rel=stylesheet href=https://s4.zstatic.net/ajax/libs/normalize/8.0.1/normalize.min.css crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://s4.zstatic.net/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css crossorigin=anonymous referrerpolicy=no-referrer><link href='/asset/blog.css?time=2025-10-26T19%3a03%3a29Z%2b08%3a00' rel=stylesheet type=text/css><script src=https://s4.zstatic.net/npm/currency.js@2.0.4/dist/currency.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://s4.zstatic.net/ajax/libs/moment.js/2.30.1/moment.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src='/asset/blog.js?time=2025-10-26T19%3a03%3a29Z%2b08%3a00' type=application/javascript></script><script type=text/javascript>blog.isMobile()&&document.write('<link href="/asset/blog.mobile.css?time=2025-10-26T19%3A03%3A29Z%2B08%3A00" rel="stylesheet">')</script></head><body><div id=horizontal-progress class=horizontal-progress></div><aside id=toc class=toc><section class=toc-header><a class=toc-page-title href=/computer-networking/ target=_blank>[计算机网络]</a></section><section class=toc-page><a class=toc-page-title href=/computer-networking/00-overview/ target=_blank>[计算机网络] 00 概述</a></section><section class=toc-page><a class=toc-page-title href=/computer-networking/01-layer-physical/ target=_blank>[计算机网络] 01 [Layer] Physical</a></section><section class=toc-page><a class=toc-page-title href=/computer-networking/02-layer-data-link/ target=_blank>[计算机网络] 02 [Layer] Data Link</a></section><section class=toc-page><a class=toc-page-title href=/computer-networking/03-layer-internet/ target=_blank>[计算机网络] 03 [Layer] Internet</a></section><section class="toc-page selected"><span class=toc-page-title>[计算机网络] TCP</span><nav id=TableOfContents><ul><li><a href=#feature>1 特点介绍</a></li><li><a href=#connection-management>2 连接管理</a><ul><li><a href=#connection-number>2.1 连接数</a></li><li><a href=#establish-connection>2.2 建立连接</a></li><li><a href=#transfer-data>2.3 传输数据</a></li><li><a href=#close-connection>2.4 关闭连接</a></li></ul></li><li><a href=#flow-control>3 流量控制</a></li><li><a href=#congestion-control>4 拥塞控制</a><ul><li><a href=#slow-start>4.1 慢启动算法</a></li><li><a href=#congestion-avoidance>4.2 拥塞避免算法</a></li></ul></li><li><a href=#reference>5 Reference</a></li></ul></nav></section><section class=toc-page><a class=toc-page-title href=/computer-networking/nat/ target=_blank>[计算机网络] NAT</a></section><section class=toc-page><a class=toc-page-title href=/computer-networking/io-model/ target=_blank>[计算机网络] IO 模型</a></section><section class=toc-page><a class=toc-page-title href=/computer-networking/tool/ target=_blank>[计算机网络] Tool</a></section><section class=toc-page><a class=toc-page-title href=/computer-networking/dns/ target=_blank>[计算机网络] DNS(Domain Name System)</a></section><section class=toc-page><a class=toc-page-title href=/computer-networking/doh/ target=_blank>[计算机网络] DoH(DNS over HTTPS)</a></section><script type=text/javascript>blog.isPC()&&blog.toggleToc()</script></aside><main class=main><header class=header><hgroup class=header-hgroup><h1 class=header-hgroup-title><a href=/>Timetombs</a></h1><h2 class=header-hgroup-subtitle>泛义的工具是文明的基础，而确指的工具却是愚人的器物</h2></hgroup><nav class=header-nav><a class=header-nav-item href=/topic/ title=专题 target=_self><i class="fa fa-folder"></i>专题</a>
<a class=header-nav-item href=/tag/ title=标签 target=_self><i class="fa fa-tags"></i>标签</a>
<a class=header-nav-item href=/archive/ title=归档 target=_self><i class="fa fa-archive"></i>归档</a>
<a class=header-nav-item href=https://linianhui.cnblogs.com title=博客园 target=_black><img src=/asset/cnblogs.favicon.svg>博客园</a>
<a class=header-nav-item href=https://github.com/linianhui/blog title=GitHub target=_black><i class="fa fa-github"></i>GitHub</a></nav><div class=header-stats><div class=stats><span>共
<i>66<sub>h</sub>
</i>/
<i>118<sub>a</sub>
</i>篇</span><div class=stats-date>，更新于 2025-10-26T19:03:29Z+08:00 by &nbsp;
<a class=git-commit href=https://github.com/linianhui/blog/commit/2fac07e818d6d4ad6b78781efea82c28769c8c02 target=_blank><i class="fa fa-code-fork"></i>2fac07e</a></div></div><form class=search method=GET target=_blank action=https://www.bing.com/search><input name=q class=search-input type=search placeholder=search... results=5 onkeypress="search_param.value=search_param_site.value+this.value">
<input id=search_param_site type=hidden value="site:linianhui.github.io ">
<input name=q id=search_param type=hidden></form></div></header><main class=content><article class=article><h1 class=article-title>[计算机网络] TCP</h1><div class=article-copyright><span>版权声明 - </span><a href=/copyright/cc target=_blank>CC BY-NC-SA 4.0</a></div><section class=article-meta><section class=article-date>2020-02-20 20:55，约6410字，阅读约13分钟</section><section class=article-topics><a class=article-topic href=/computer-networking/ title=[计算机网络] target=_blank><i class="fa fa-folder"></i>[计算机网络]</a></section><section class=article-tags><a class=article-tag href=/tag/ack target=_blank><i class="fa fa-tag"></i>ack</a>
<a class=article-tag href=/tag/cwnd target=_blank><i class="fa fa-tag"></i>cwnd</a>
<a class=article-tag href=/tag/fin target=_blank><i class="fa fa-tag"></i>fin</a>
<a class=article-tag href=/tag/full-duplex target=_blank><i class="fa fa-tag"></i>full duplex</a>
<a class=article-tag href=/tag/pcap target=_blank><i class="fa fa-tag"></i>pcap</a>
<a class=article-tag href=/tag/rwnd target=_blank><i class="fa fa-tag"></i>rwnd</a>
<a class=article-tag href=/tag/segment target=_blank><i class="fa fa-tag"></i>segment</a>
<a class=article-tag href=/tag/syn target=_blank><i class="fa fa-tag"></i>syn</a>
<a class=article-tag href=/tag/tcp target=_blank><i class="fa fa-tag"></i>tcp</a>
<a class=article-tag href=/tag/time_wait target=_blank><i class="fa fa-tag"></i>time_wait</a></section><section class=article-git><a class=article-git-commit href=https://github.com/linianhui/blog/commit/03e0cc08866458647d96951c1817c624518149d6 target=_blank><i class="fa fa-code-fork"></i>03e0cc0</a>
<span class=article-git-commit-subject>fix add displayed_on_home</span>
<span class=article-git-commit-time>2022-11-20 14:49</span>
<a class=article-git-source href=https://github.com/linianhui/blog/blob/main/src/computer-networking/tcp/index.md target=_blank><i class="fa fa-github"></i>源码</a></section></section><section class=article-content><p>TCP(Transmission Control Protocol)是一种<strong>全双工的</strong>、<strong>面向连接的</strong>、<strong>基于字节流的</strong>、<strong>可靠的（尽最大努力交付）</strong>、<strong>有状态的</strong> 传输层通信协议。先看一TCP的数据包<code>Segment</code><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>长什么样子，后续的各种功能都会体现在其中：<br><div class="highlight-file highlight-file_opened" id=hf-53b13545c7cc9b624b918f7873fa7667><div class=highlight-file-header><a class="fa fa-plus highlight-file-switch" onclick='blog.toggleClassName("hf-53b13545c7cc9b624b918f7873fa7667","highlight-file_opened")'>tcp.segment</a><a class="fa fa-download highlight-file-download" target=_blank href=/computer-networking/tcp/tcp.segment title="下载 tcp.segment" download></a>
<a class="fa fa-github" target=_blank href=https://github.com/linianhui/blog/blob/main/src/computer-networking/tcp/tcp.segment title="源码 tcp.segment"></a></div><div class=highlight-file-content><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>                           TCP Segment
</span></span><span style=display:flex><span>|- - - - - - - -+- - - 32 bits(4 octets) - - - -+- - - - - - - -|
</span></span><span style=display:flex><span>|0 1 2 3 4 5 6 7+0 1 2 3 4 5 6 7+0 1 2 3 4 5 6 7+0 1 2 3 4 5 6 7|
</span></span><span style=display:flex><span>|- - - - - - - -+- - - - - - - -+- - - - - - - -+- - - - - - - -|
</span></span><span style=display:flex><span>|     Source Port (2 octets)    |  Destination Port (2 octets)  |
</span></span><span style=display:flex><span>|- - - - - - - -+- - - - - - - -+- - - - - - - -+- - - - - - - -|
</span></span><span style=display:flex><span>|                Sequence number (4 octets)                     |
</span></span><span style=display:flex><span>|- - - - - - - -+- - - - - - - -+- - - - - - - -+- - - - - - - -|
</span></span><span style=display:flex><span>|           Acknowledgment number (if ACK set)                  |
</span></span><span style=display:flex><span>|- - - - - - - -+- - - - - - - -+- - - - - - - -+- - - - - - - -|
</span></span><span style=display:flex><span>| data  |     |N|C|E|U|A|P|R|S|F|                               |
</span></span><span style=display:flex><span>|offset |     |S|W|C|R|C|S|S|Y|I|    Window Size (2 octets)     |
</span></span><span style=display:flex><span>|(4 bit)|     | |R|E|G|K|H|T|N|N|                               |
</span></span><span style=display:flex><span>|- - - - - - - -+- - - - - - - -+- - - - - - - -+- - - - - - - -|
</span></span><span style=display:flex><span>|    Checksum                   |  Urgent pointer (if URG set)  |
</span></span><span style=display:flex><span>|- - - - - - - -+- - - - - - - -+- - - - - - - -+- - - - - - - -|
</span></span><span style=display:flex><span>| Options (if data offset &gt; 5)                                  |
</span></span><span style=display:flex><span>| Padded at the end with &#34;0&#34; bytes if necessary.)               |
</span></span><span style=display:flex><span>|- - - - - - - -+- - - - - - - -+- - - - - - - -+- - - - - - - -|
</span></span><span style=display:flex><span>|                                                               |
</span></span><span style=display:flex><span>|                              data                             |
</span></span><span style=display:flex><span>|                                                               |
</span></span><span style=display:flex><span>|- - - - - - - -+- - - - - - - -+- - - - - - - -+- - - - - - - -|
</span></span><span style=display:flex><span># https://en.wikipedia.org/wiki/Transmission_Control_Protocol</span></span></code></pre></div></div></div></p><h1 id=feature><i id=locator-feature class=header-locator></i>
<a href=#feature class=article-h-a>1 特点介绍</a></h1><ol><li><strong>全双工的</strong>：通信双方在同一时刻都可以发送和接收数据。</li><li><strong>面向连接的</strong>：在双方通信之前，必须要建立一条通道，这个通道并不是说要铺设一条物理线缆，而是一条<strong>逻辑通道</strong>。</li><li><strong>基于字节流的</strong>：底层的通信基础基于<code>分组交换</code><sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>，数据是分成一组一组的，而TCP则是屏蔽了底层这些细节，而像上层提供了一个类似队列一样的byte-stream。</li><li><strong>可靠的（尽最大努力交付）</strong>：由于<code>分组交换</code>和网络的天然不可靠状态，所以TCP只能做到尽最大努力可靠。</li><li><strong>有状态的</strong>：通信双方需要维持连接的状态。</li></ol><h1 id=connection-management><i id=locator-connection-management class=header-locator></i>
<a href=#connection-management class=article-h-a>2 连接管理</a></h1><p>既然是面向连接的协议，那么TCP就需要负责连接的创建、维护和关闭等操作。下图是TCP的状态迁移流程图。</p><img src=state-diagram.svg loading=lazy decoding=auto alt="TCP State Diagram" title="TCP State Diagram"><p>这里我们通过<code>tcpdump port 80 -w nginx.pcap</code><sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>来抓取访问Nginx首页(<code>curl http://172.17.0.2</code>)这一过程的数据包<a href=nginx.pcap target=_blank rel="noopener norefferrer">nginx.pcap</a>来分析一下TCP的建立连接、传输数据和关闭连接的过程中的关键信息。下面的信息是<code>tcpdump -r nginx.pcap -nSt</code>的打印结果。</p><div class="highlight-file highlight-file_opened" id=hf-1fb302c673620b6d2b4eeba0ed27aa28><div class=highlight-file-header><a class="fa fa-plus highlight-file-switch" onclick='blog.toggleClassName("hf-1fb302c673620b6d2b4eeba0ed27aa28","highlight-file_opened")'>nginx.pcap.txt</a><a class="fa fa-download highlight-file-download" target=_blank href=/computer-networking/tcp/nginx.pcap.txt title="下载 nginx.pcap.txt" download></a>
<a class="fa fa-github" target=_blank href=https://github.com/linianhui/blog/blob/main/src/computer-networking/tcp/nginx.pcap.txt title="源码 nginx.pcap.txt"></a></div><div class=highlight-file-content><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>01 IP 172.17.0.3.40278 &gt; 172.17.0.2.80: Flags [S], seq 4068139125, win 64240, options [mss 1460,sackOK,TS val 689579838 ecr 0,nop,wscale 7], length 0
</span></span><span style=display:flex><span>02 IP 172.17.0.2.80 &gt; 172.17.0.3.40278: Flags [S.], seq 4161524589, ack 4068139126, win 65160, options [mss 1460,sackOK,TS val 715423005 ecr 689579838,nop,wscale 7], length 0
</span></span><span style=display:flex><span>03 IP 172.17.0.3.40278 &gt; 172.17.0.2.80: Flags [.], ack 4161524590, win 502, options [nop,nop,TS val 689579838 ecr 715423005], length 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>04 IP 172.17.0.3.40278 &gt; 172.17.0.2.80: Flags [P.], seq 4068139126:4068139200, ack 4161524590, win 502, options [nop,nop,TS val 689579838 ecr 715423005], length 74: HTTP: GET / HTTP/1.1
</span></span><span style=display:flex><span>05 IP 172.17.0.2.80 &gt; 172.17.0.3.40278: Flags [.], ack 4068139200, win 509, options [nop,nop,TS val 715423005 ecr 689579838], length 0
</span></span><span style=display:flex><span>06 IP 172.17.0.2.80 &gt; 172.17.0.3.40278: Flags [P.], seq 4161524590:4161524828, ack 4068139200, win 509, options [nop,nop,TS val 715423006 ecr 689579838], length 238: HTTP: HTTP/1.1 200 OK
</span></span><span style=display:flex><span>07 IP 172.17.0.3.40278 &gt; 172.17.0.2.80: Flags [.], ack 4161524828, win 501, options [nop,nop,TS val 689579839 ecr 715423006], length 0
</span></span><span style=display:flex><span>08 IP 172.17.0.2.80 &gt; 172.17.0.3.40278: Flags [P.], seq 4161524828:4161525440, ack 4068139200, win 509, options [nop,nop,TS val 715423006 ecr 689579839], length 612: HTTP
</span></span><span style=display:flex><span>09 IP 172.17.0.3.40278 &gt; 172.17.0.2.80: Flags [.], ack 4161525440, win 501, options [nop,nop,TS val 689579839 ecr 715423006], length 0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>10 IP 172.17.0.3.40278 &gt; 172.17.0.2.80: Flags [F.], seq 4068139200, ack 4161525440, win 501, options [nop,nop,TS val 689579839 ecr 715423006], length 0
</span></span><span style=display:flex><span>11 IP 172.17.0.2.80 &gt; 172.17.0.3.40278: Flags [F.], seq 4161525440, ack 4068139201, win 509, options [nop,nop,TS val 715423006 ecr 689579839], length 0
</span></span><span style=display:flex><span>12 IP 172.17.0.3.40278 &gt; 172.17.0.2.80: Flags [.], ack 4161525441, win 501, options [nop,nop,TS val 689579839 ecr 715423006], length 0</span></span></code></pre></div></div></div><p>其中的关键信息：</p><ol><li><code>ip</code>，<code>port</code>：通信双方的ip和port。</li><li><code>flags</code>：<code>S=SYN</code>，<code>.=ACK</code>，<code>P=PSH</code>，<code>F=FIN</code>。标记位，每个标记1bit，代表不同的含义。</li><li><code>seq</code>：<code>Sequence number (4 octets)</code>。序列号，长度32bit。</li><li><code>ack</code>：<code>Acknowledgment number (4 octets)</code>。确认号，长度32bit。</li><li><code>win</code>：<code>Window Size (2 octets)</code>。窗口大小，长度16bit。</li><li><code>length</code>：data部分的长度。</li><li><code>wscale</code>：Window Scale 窗口缩放因子。用于解决win太小的问题。</li></ol><h2 id=connection-number><i id=locator-connection-number class=header-locator></i>
<a href=#connection-number class=article-h-a>2.1 连接数</a></h2><p><strong>理论上一台服务器最大可以支持多少个TCP连接呢</strong>？TCP使用四元组 (<code>source_ip</code>, <code>source_port</code>, <code>destination_ip</code>, <code>destination_port</code>) 标识一个连接。</p><p>假设服务器只有一个IP<code>172.17.0.2</code>，端口号固定是<code>80</code>。那么<code>destination_ip</code>, <code>destination_port</code>) 就是固定的。因此最大连接数=<code>source_ip</code>的数量乘以<code>source_port</code>的数量。</p><ol><li>IPv4 : <code>2<sup>32</sup> * 2<sup>16</sup> = 2<sup>48</sup> = 40亿+</code></li><li>IPv6 : <code>2<sup>128</sup> * 2<sup>16</sup> = 2<sup>144</sup></code></li></ol><p>单单IPv4就可以支持多大40亿+的连接了。但是有时候才1000多个连接就会遇到这样的错误<code>Socket : Can't open so many files</code>。这是因为Linux系统默认限制了一个进程可以打开的fd(文件描述符：一个连接对应一个文件描述符)数量，其默认值是<code>1024</code>。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:green># 查看默认限制</span>
</span></span><span style=display:flex><span>ulimit -n
</span></span><span style=display:flex><span>1024
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green># 临时修改</span>
</span></span><span style=display:flex><span>ulimit -n 1024000
</span></span><span style=display:flex><span><span style=color:green># 查看修改</span>
</span></span><span style=display:flex><span>ulimit -n
</span></span><span style=display:flex><span>1024000
</span></span></code></pre></div><h2 id=establish-connection><i id=locator-establish-connection class=header-locator></i>
<a href=#establish-connection class=article-h-a>2.2 建立连接</a></h2><p>TCP是基于<code>ACK</code>（收到数据后需要回复确认）的协议，并且是<code>全双工的</code>的协议，那么通信双方均需要确认<code>自身</code>和<code>对方</code>都具备<code>发送</code>和<code>接收</code>数据的能力。按最简化的模型来说需要<mark>4步</mark>才能建立连接。如下图，<code>A</code>和<code>B</code>是通信双方：</p><img src=4-step-handshake.svg loading=lazy decoding=auto alt="4 step handshake" title="4 step handshake"><p>聪明的你明显就可以看出2和3可以合并处理，从而变成<mark>3步</mark>握手。至此双方都可以确认自身和对方的收发功能是正常的。</p><table><tr><th rowspan=2>序号</th><th rowspan=2>方向</th><th colspan=4>A确认</th><th colspan=4>B确认</th></tr><tr><td>A发送</td><td>A接收</td><td>B发送</td><td>B接收</td><td>B发送</td><td>B接收</td><td>A发送</td><td>A接收</td></tr><tr><td>1</td><td>A -> B</td><td></td><td></td><td></td><td></td><td></td><td>✔</td><td>✔</td><td></td></tr><tr><td>2</td><td>A &lt;- B</td><td>✔</td><td>✔</td><td>✔</td><td>✔</td><td></td><td></td><td></td><td></td></tr><tr><td>3</td><td>A -> B</td><td></td><td></td><td></td><td></td><td>✔</td><td>✔</td><td>✔</td><td>✔</td></tr></table><p>那么我们就详细分析下上文的<code>nginx.pcap.txt</code>这部分tcpdump的结果的前3行。</p><ol><li>01行：client使用了一个随机的端口<code>40278</code>来连接server的<code>80</code>端口。设置了<code>SYN</code>flags（表示自己要求建立连接）；生成了一个随机的<code>seq</code>=<code>c</code>=4068139125；<code>win</code>=64240，<code>length</code>=0（建立连接阶段不携带数据，故而为0）。client此时进入<code>SYN_SENT</code>状态。</li><li>02行：server设置了<code>SYN</code>和<code>ACK</code>flags（表示我已收到你的建立连接请求，并且同意建立连接）。同时生成了自己的<code>seq</code>=<code>s</code>=4161524589；然后设置<code>ack</code>=4068139126（=<code>c+1</code>），虽然client没有发送data，但是握手阶段依然会增加1byte的ack；<code>win</code>=65160；<code>length</code>=0。server此时进入<code>SYN_RECEIVED</code>状态。</li><li>03行：client设置了<code>ACK</code>flags，然后设置<code>ack</code>=4161524590（=<code>s+1</code>），<code>win</code>=502，<code>length</code>=0。此时client到<code>ESTABLISHED</code>状态，表示连接已经建立。</li></ol><p>在server收到03的数据后，也会进入到<code>ESTABLISHED</code>状态。</p><h2 id=transfer-data><i id=locator-transfer-data class=header-locator></i>
<a href=#transfer-data class=article-h-a>2.3 传输数据</a></h2><p>上文的<code>nginx.pcap.txt</code>的04行到09行均是实质性的数据传输部分。</p><ol start=4><li>04行：client设置了<code>PSH</code>和<code>ACK</code>的flags。<code>PSH</code>的含义是指示server在收到数据后应该尽快交付给上层应用。<code>seq 4068139126:4068139200</code>看起来有点奇怪，不过其实际的seq是<code>4068139126</code>，冒号后面的数字是tcpdump用seq加length<code>74</code>自己计算出来的。ack<code>4161524590</code>和03行一样，因为目前还未收到server的数据，故而保持不变。</li><li>05行：server回复了一个ack<code>4068139200</code>，表示自己收到了你的seq<code>4068139126</code>+length<code>74</code>这部分数据了。</li><li>06行：server开始返回的数据，seq<code>4161524590</code>，length<code>238</code>。同时也携带了一个和05行一样的ack。</li><li>07行：client收到了server发送的seq<code>4161524590</code>+length<code>238</code>的数据，回复了一个ack<code>4161524828</code>。</li><li>08行：server继续返回数据，这次是length<code>612</code>。</li><li>09行：client收到了612的数据，回复ack<code>4161525440</code>=<code>4161524828+612</code>。</li></ol><h2 id=close-connection><i id=locator-close-connection class=header-locator></i>
<a href=#close-connection class=article-h-a>2.4 关闭连接</a></h2><p>TCP是<code>全双工的</code>，通信双方可以进行独立的关闭（半关闭：half-clone）。A方发送<code>FIN</code>只是代表A不再发送数据了，但是还可以接收B方发送的数据。当B收到A的<code>FIN</code>时：B需要给A发送一个ACK；但是TCP并不知道B方是否也需要关闭，而是要由上层应用来决定，故而不能像建立连接时直接在协议层面就规定直接合并<code>ACK</code>和<code>FIN</code>。所以关闭时需要<mark>4步</mark>。但是如果B收到A的关闭请求时，正正好自己也要关闭，那么其实现实中是可以合并成<mark>3步</mark>（上文的<code>nginx.pcap.txt</code>的最后三行）。</p><ol start=10><li>10行：client主动发起关闭，设置了<code>FIN</code>flags（表示自己要求断开连接），seq<code>4068139125</code>，client此时进入<code>FIN_WAIT_1</code>状态。此时client还能接收server发送的数据，但是自己已经不能发送了。</li><li>11行：server碰巧这时候也要关闭连接，所以合并了对10行的ack和自己的<code>FIN</code>。server此时直接进入<code>LAST_ACK</code>状。<br>> 如果server现在不想关闭连接，那么只对client的<code>FIN</code>回复ACK时，则是进入到<code>CLOSE_WAIT</code>状态，此时自身还可以继续发送数据给client。当自己也发送了<code>FIN</code>后，才会进入到<code>LAST_ACK</code>状态，这时server已经不能再发送数据了。</li><li>12行：client同时收到了server的<code>ACK</code>和<code>FIN</code>。然后发出对server的<code>FIN</code>的最后一个<code>ACK</code>，此时cleint进入<code>TIME_WAIT</code>状态。通常此时client都会维持这个状态2<code>MSL</code><sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>时长后才会进入到<code>CLOSED</code>状态。<br>> 两种特殊情况：<br>> 1. client这时只收到了<code>ACK</code>，但是没有收到<code>FIN</code>，也就是说server目前还不想关闭连接，那么此时client进入到<code>FIN_WAIT_2</code>状态，这时client还依然可以接收server发送的数据。当收到server的<code>FIN</code>时，才会进入到<code>TIME_WAIT</code>状态。<br>> 2. client这时只收到server的<code>FIN</code>，但是没有收到自己的<code>FIN</code>的<code>ACK</code>，非常罕见的情况，此时client会进入到<code>CLOSING</code>状态，待收到<code>ACK</code>后，进入到<code>TIME_WAIT</code>状态。</li></ol><p>最后，server收到了client的ack，server则进入到<code>CLOSED</code>状态，致此server端已经彻底关闭连接。</p><h1 id=flow-control><i id=locator-flow-control class=header-locator></i>
<a href=#flow-control class=article-h-a>3 流量控制</a></h1><p>TCP是基于底层的分组交换向上层提供基于字节流的数据服务的。因为底层分组交换的特性，所以双方收到的Segment的顺序并不一定是对方发送的顺序；也由于底层网络的不可靠性，甚至出现丢包需要重传的现象。同时底层硬件的所支持的网络速率也不尽相同。还有就是即使数据已经收到了，但是上层应用并未来得及去处理。</p><p>基于这些客观因素，则TCP协议的实现程序中就有必要设置一定的接收缓冲区，用来暂存收到的数据。</p><blockquote><p>也有发送缓冲区，意思是上层应用交给TCP的数据并不一定立即就会发送出去，TCP自身可以自由决定分组发送。</p></blockquote><p>既然有了缓冲区，那么肯定就会有上限容量。如果己方接收缓冲区满了，上层应用来不及去读取，而对方还在不停的发送数据，则这部分数据就只能被丢弃，导致浪费。所以就需要一种途径来告诉对方自身的接收缓冲区有多大。<strong>在Segment中的<code>Window Size</code>就是干这个的，大小为16bit，单位是byte，最大64Kb。在建立连接的3步握手时，双方除了交换自身的seq外，还交换了这个信息</strong>。Window Size并不是固定不变的，而是会动态变化的，比如一开始64kb，收到了64kb，但是上层应用一直没有去读取，这时就变成了0kb。这个0kb的值会随着ack告知对方，对方发现已经是0，就会选择暂停发送，以等待下次窗口变化。这里的Window Size因为是接收窗口，故而称之为<mark>rwnd</mark>(receive window)。</p><blockquote><p>rwnd变成0后，发送会也会选择定时的发送一个称为<code>ZWPs=Zero Window Probes</code>的包，让接收方来ACK一下其窗口的变化。如果经过几次ZWP依然是0，那么发送方就会选择<code>RST</code>掉这次连接。</p></blockquote><p>64kb的大小对于现在的应用来说太小了，但是TCP上只给它分配了16bit，只能这么多，怎么办？这时就需要Segment中的可选部分option区域登场了，可以在连接时设置option，其中包含<code>wscale 7</code>。代表的含义时说<code>Window Size</code>的实际大小应该扩大<code>2<sup>7</sup>=128</code>倍。这个机制称之为<code>TCP Window Scale</code><sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>。</p><p>那么rwnd通常设置多大合适呢？通常是取决于<code>BDP=Bandwidth Delay Product</code>（带宽和延迟的乘积）<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>的大小。比如<code>Bandwidth</code><sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>是100Mbps，<code>Delay</code><sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup>是100ms，那么BDP为：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>BDP = 100Mbps * 100ms = (100 / 8) * (100 / 1000) = 1.25MB
</span></span></code></pre></div><p>如果想要尽可能的跑慢带宽，那么rwnd不应该低于1.25MB。注意<code>Window Size</code>最大只是64kb，这时就需要<code>TCP Window Scale</code>来搭配了。</p><h1 id=congestion-control><i id=locator-congestion-control class=header-locator></i>
<a href=#congestion-control class=article-h-a>4 拥塞控制</a></h1><p>单单有了<mark>rwnd</mark>还是远远不够的，因为它只是通信双方自身接收窗口的信息，而不知道实际的网络情况到底如何。就好比北京和广州两个仓库之间交换货物，仅知道了对方的仓库容量可以容纳得下自己的货物了。但是不知道两地之间的高速路上是不是畅通无阻，还是已经拥挤不堪了，如果此时选择大规模的上高速，那么只会让高速变得更加拥堵。</p><p>所以就需要另外一个能够实时反映线路拥堵情况的指标来指导双方应该以何种速率来发送数据。这个重要的指标就是<mark>cwnd</mark>(congestion window)。这个指标参数只是发送方内部自己根据<code>RTT</code><sup id=fnref:9><a href=#fn:9 class=footnote-ref role=doc-noteref>9</a></sup>以及<code>ACK</code>的情况估算出来的，并不体现在TCP的<code>Segment</code>中。也是因为它是算出来的，故而相关的解决方案都称之为算法。</p><h2 id=slow-start><i id=locator-slow-start class=header-locator></i>
<a href=#slow-start class=article-h-a>4.1 慢启动算法</a></h2><p>在刚开始传输数据时，保守一些，假设网络是拥挤的，先发送少量的数据试探一下，根据对方的ACK以及RTT来判断后续是否可以加大发送的数据量。具体的过程如下：</p><ol><li>默认<code>cwnd=1</code>MSS<sup id=fnref:10><a href=#fn:10 class=footnote-ref role=doc-noteref>10</a></sup>。根据google的研究<sup id=fnref:11><a href=#fn:11 class=footnote-ref role=doc-noteref>11</a></sup>，目前默认已经是10。</li><li>收到一个ACK：<code>cwnd++</code>线性上升。</li><li>经过一个RTT：<code>cwnd=cwnd*2</code>指数让升。</li><li><code>cwnd >= ssthresh</code>(slow start threshold)时，换成<a href=#congestion-avoidance>拥塞避免算法</a>。</li></ol><h2 id=congestion-avoidance><i id=locator-congestion-avoidance class=header-locator></i>
<a href=#congestion-avoidance class=article-h-a>4.2 拥塞避免算法</a></h2><p>当cwnd超过ssthresh后，改成如下方式处理：</p><ol><li>收到一个ACK：<code>cwnd = cwnd + 1/cwnd</code></li><li>经过一个RTT：<code>cwnd = cwnd + 1</code></li></ol><p>避免增长过快导致网络拥塞，慢慢的增加。</p><p>未完待续。</p><h1 id=reference><i id=locator-reference class=header-locator></i>
<a href=#reference class=article-h-a>5 Reference</a></h1><p>常用到的一些配置信息：<br><div class="highlight-file highlight-file_opened" id=hf-458957c1a22b82be80ebd3ffd8571e05><div class=highlight-file-header><a class="fa fa-plus highlight-file-switch" onclick='blog.toggleClassName("hf-458957c1a22b82be80ebd3ffd8571e05","highlight-file_opened")'>sysctl.conf</a><a class="fa fa-download highlight-file-download" target=_blank href=/computer-networking/tcp/sysctl.conf title="下载 sysctl.conf" download></a>
<a class="fa fa-github" target=_blank href=https://github.com/linianhui/blog/blob/main/src/computer-networking/tcp/sysctl.conf title="源码 sysctl.conf"></a></div><div class=highlight-file-content><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span>net.ipv4.tcp_window_scaling=<span style=color:#a31515>1</span></span></span></code></pre></div></div></div></p><p><a href=http://www.52im.net/thread-561-1-1.html target=_blank rel="noopener norefferrer">http://www.52im.net/thread-561-1-1.html</a><br><a href="http://www.52im.net/forum.php?mod=viewthread&amp;tid=515" target=_blank rel="noopener norefferrer">http://www.52im.net/forum.php?mod=viewthread&tid=515</a></p><p><a href=https://zhuanlan.zhihu.com/p/144273871 target=_blank rel="noopener norefferrer">https://zhuanlan.zhihu.com/p/144273871</a></p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Segment：<a href=https://linianhui.github.io/computer-networking/00-overview/#layered-architecture target=_blank rel="noopener norefferrer">https://linianhui.github.io/computer-networking/00-overview/#layered-architecture</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>分组交换：<a href=https://linianhui.github.io/computer-networking/00-overview/#packet-switching target=_blank rel="noopener norefferrer">https://linianhui.github.io/computer-networking/00-overview/#packet-switching</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>tcpdump：<a href=https://www.tcpdump.org target=_blank rel="noopener norefferrer">https://www.tcpdump.org</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><code>MSL=Maximum Segment Lifetime</code>：<a href=https://en.wikipedia.org/wiki/Maximum_segment_lifetime target=_blank rel="noopener norefferrer">https://en.wikipedia.org/wiki/Maximum_segment_lifetime</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>Window Scale Option：<a href=https://en.wikipedia.org/wiki/TCP_window_scale_option target=_blank rel="noopener norefferrer">https://en.wikipedia.org/wiki/TCP_window_scale_option</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p><code>BDP=Bandwidth Delay Product</code>：<a href=https://en.wikipedia.org/wiki/Bandwidth-delay_product target=_blank rel="noopener norefferrer">https://en.wikipedia.org/wiki/Bandwidth-delay_product</a>&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p>带宽：<a href=https://linianhui.github.io/computer-networking/00-overview/#bandwidth target=_blank rel="noopener norefferrer">https://linianhui.github.io/computer-networking/00-overview/#bandwidth</a>&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8><p>延迟：<a href=https://linianhui.github.io/computer-networking/00-overview/#delay target=_blank rel="noopener norefferrer">https://linianhui.github.io/computer-networking/00-overview/#delay</a>&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:9><p><code>RTT=Round Trip Time</code>：<a href=https://linianhui.github.io/computer-networking/00-overview/#round-trip-time target=_blank rel="noopener norefferrer">https://linianhui.github.io/computer-networking/00-overview/#round-trip-time</a>&#160;<a href=#fnref:9 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:10><p><code>MSS=Maximum Segment Size</code>：<a href=https://en.wikipedia.org/wiki/Maximum_segment_size target=_blank rel="noopener norefferrer">https://en.wikipedia.org/wiki/Maximum_segment_size</a>&#160;<a href=#fnref:10 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:11><p><a href=https://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36640.pdf target=_blank rel="noopener norefferrer">https://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36640.pdf</a>&#160;<a href=#fnref:11 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></section><section class=article-meta><section class=article-date>2020-02-20 20:55，约6410字，阅读约13分钟</section><section class=article-topics><a class=article-topic href=/computer-networking/ title=[计算机网络] target=_blank><i class="fa fa-folder"></i>[计算机网络]</a></section><section class=article-tags><a class=article-tag href=/tag/ack target=_blank><i class="fa fa-tag"></i>ack</a>
<a class=article-tag href=/tag/cwnd target=_blank><i class="fa fa-tag"></i>cwnd</a>
<a class=article-tag href=/tag/fin target=_blank><i class="fa fa-tag"></i>fin</a>
<a class=article-tag href=/tag/full-duplex target=_blank><i class="fa fa-tag"></i>full duplex</a>
<a class=article-tag href=/tag/pcap target=_blank><i class="fa fa-tag"></i>pcap</a>
<a class=article-tag href=/tag/rwnd target=_blank><i class="fa fa-tag"></i>rwnd</a>
<a class=article-tag href=/tag/segment target=_blank><i class="fa fa-tag"></i>segment</a>
<a class=article-tag href=/tag/syn target=_blank><i class="fa fa-tag"></i>syn</a>
<a class=article-tag href=/tag/tcp target=_blank><i class="fa fa-tag"></i>tcp</a>
<a class=article-tag href=/tag/time_wait target=_blank><i class="fa fa-tag"></i>time_wait</a></section><section class=article-git><a class=article-git-commit href=https://github.com/linianhui/blog/commit/03e0cc08866458647d96951c1817c624518149d6 target=_blank><i class="fa fa-code-fork"></i>03e0cc0</a>
<span class=article-git-commit-subject>fix add displayed_on_home</span>
<span class=article-git-commit-time>2022-11-20 14:49</span>
<a class=article-git-source href=https://github.com/linianhui/blog/blob/main/src/computer-networking/tcp/index.md target=_blank><i class="fa fa-github"></i>源码</a></section></section><section class=article-page><div class=article-page-prev><span>上一篇 : </span><a href=/computer-networking/03-layer-internet/ target=_blank>[计算机网络] 03 [Layer] Internet</a></div><div class=article-page-next><span>下一篇 : </span><a href=/computer-networking/nat/ target=_blank>[计算机网络] NAT</a></div></section></article><section id=article-comment class=article-comment><script src=https://utteranc.es/client.js repo=linianhui/blog issue-term=pathname label=blog-comment theme=github-light crossorigin=anonymous async></script></section></main><footer class=footer><section>Copyright © 2025 by <a href=https://github.com/linianhui/blog target=_blank>Timetombs</a></section><section><a class=article-git-commit href=https://github.com/linianhui/blog/commit/2fac07e818d6d4ad6b78781efea82c28769c8c02 target=_blank><i class="fa fa-code-fork"></i>2fac07e</a>
Powered by
<a href=https://github.com/actions target=_blank>GitHub Actions</a>
,
<a href=https://github.com/gohugoio/hugo target=_blank>Hugo</a>
and
<a href=https://github.com/utterance/utterances target=_blank>utterances</a>
Hosted on <a href=https://pages.github.com/ target=_blank>GitHub Pages</a><section></footer></main><aside class=toolbar><a class="fa fa-list" href=javascript:blog.toggleToc(); title=目录></a><a class="fa fa-comments" href=#article-comment title=评论></a><a class="fa fa-arrow-up" href=javascript:scroll(0,0); title=返回顶部></a></aside><script type=text/javascript>var _hmt=_hmt||[];blog.addOnScorllEvent()</script><script src=https://hm.baidu.com/hm.js?b2cc3cea316e1f7a8def1bab8dc98fad async></script></body></html>