<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=google-site-verification content="X6gTMGCy1-_vb5i3aja3ZZyzPY3raiKRJp4VIhOAX24"><meta name=msvalidate.01 content="CDE7502649B75529BD0FCFE89B056E38"><title>[Java] Unsafe类 - Timetombs</title>
<link rel=icon type=image/svg href=/favicon.svg><link rel=stylesheet href=https://s4.zstatic.net/ajax/libs/normalize/8.0.1/normalize.min.css crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://s4.zstatic.net/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css crossorigin=anonymous referrerpolicy=no-referrer><link href='/asset/blog.css?time=2025-10-26T19%3a03%3a29Z%2b08%3a00' rel=stylesheet type=text/css><script src=https://s4.zstatic.net/npm/currency.js@2.0.4/dist/currency.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://s4.zstatic.net/ajax/libs/moment.js/2.30.1/moment.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src='/asset/blog.js?time=2025-10-26T19%3a03%3a29Z%2b08%3a00' type=application/javascript></script><script type=text/javascript>blog.isMobile()&&document.write('<link href="/asset/blog.mobile.css?time=2025-10-26T19%3A03%3A29Z%2B08%3A00" rel="stylesheet">')</script></head><body><div id=horizontal-progress class=horizontal-progress></div><aside id=toc class=toc><section class=toc-header><a class=toc-page-title href=/java/ target=_blank>[Java]</a></section><section class=toc-page><a class=toc-page-title href=/java/install/ target=_blank>[Java] Install</a></section><section class=toc-page><a class=toc-page-title href=/java/jvm/ target=_blank>[Java] JVM(Java Virtual Machine)</a></section><section class=toc-page><a class=toc-page-title href=/java/tool/ target=_blank>[Java] Tool</a></section><section class="toc-page selected"><span class=toc-page-title>[Java] Unsafe类</span><nav id=TableOfContents><ul><li><a href=#get-unsafe-object>1 获取Unsafe对象</a></li><li><a href=#2-unsafe提供的几种操作>2 Unsafe提供的几种操作</a><ul><li><a href=#21-获取字段偏移量>2.1 获取字段偏移量</a></li><li><a href=#22-普通读写>2.2 普通读写</a></li><li><a href=#23-有序写>2.3 有序写</a></li><li><a href=#24-volatile读写>2.4 volatile读写</a></li><li><a href=#25-cas操作>2.5 CAS操作</a></li><li><a href=#26-类加载>2.6 类加载</a></li><li><a href=#27-内存屏障>2.7 内存屏障</a></li><li><a href=#28-线程调度>2.8 线程调度</a></li></ul></li><li><a href=#3-参考资料>3 参考资料</a></li></ul></nav></section><section class=toc-page><a class=toc-page-title href=/java/jmm/ target=_blank>[Java] JMM(Java Memory Model)</a></section><section class=toc-page><a class=toc-page-title href=/java/gc/ target=_blank>[Java] GC(Garbage Collection)</a></section><section class=toc-page><a class=toc-page-title href=/java/thread/ target=_blank>[Java] Thread</a></section><section class=toc-page><a class=toc-page-title href=/java/cas/ target=_blank>[Java] CAS(Compare And Swap)</a></section><section class=toc-page><a class=toc-page-title href=/java/synchronized/ target=_blank>[Java] synchronized</a></section><script type=text/javascript>blog.isPC()&&blog.toggleToc()</script></aside><main class=main><header class=header><hgroup class=header-hgroup><h1 class=header-hgroup-title><a href=/>Timetombs</a></h1><h2 class=header-hgroup-subtitle>泛义的工具是文明的基础，而确指的工具却是愚人的器物</h2></hgroup><nav class=header-nav><a class=header-nav-item href=/topic/ title=专题 target=_self><i class="fa fa-folder"></i>专题</a>
<a class=header-nav-item href=/tag/ title=标签 target=_self><i class="fa fa-tags"></i>标签</a>
<a class=header-nav-item href=/archive/ title=归档 target=_self><i class="fa fa-archive"></i>归档</a>
<a class=header-nav-item href=https://linianhui.cnblogs.com title=博客园 target=_black><img src=/asset/cnblogs.favicon.svg>博客园</a>
<a class=header-nav-item href=https://github.com/linianhui/blog title=GitHub target=_black><i class="fa fa-github"></i>GitHub</a></nav><div class=header-stats><div class=stats><span>共
<i>66<sub>h</sub>
</i>/
<i>118<sub>a</sub>
</i>篇</span><div class=stats-date>，更新于 2025-10-26T19:03:29Z+08:00 by &nbsp;
<a class=git-commit href=https://github.com/linianhui/blog/commit/2fac07e818d6d4ad6b78781efea82c28769c8c02 target=_blank><i class="fa fa-code-fork"></i>2fac07e</a></div></div><form class=search method=GET target=_blank action=https://www.bing.com/search><input name=q class=search-input type=search placeholder=search... results=5 onkeypress="search_param.value=search_param_site.value+this.value">
<input id=search_param_site type=hidden value="site:linianhui.github.io ">
<input name=q id=search_param type=hidden></form></div></header><main class=content><article class=article><h1 class=article-title>[Java] Unsafe类</h1><div class=article-copyright><span>版权声明 - </span><a href=/copyright/cc target=_blank>CC BY-NC-SA 4.0</a></div><section class=article-meta><section class=article-date>2020-11-04 19:32，约1710字，阅读约4分钟</section><section class=article-topics><a class=article-topic href=/java/ title=[Java] target=_blank><i class="fa fa-folder"></i>[Java]</a></section><section class=article-tags><a class=article-tag href=/tag/java target=_blank><i class="fa fa-tag"></i>Java</a>
<a class=article-tag href=/tag/unsafe target=_blank><i class="fa fa-tag"></i>Unsafe</a></section><section class=article-git><a class=article-git-commit href=https://github.com/linianhui/blog/commit/03e0cc08866458647d96951c1817c624518149d6 target=_blank><i class="fa fa-code-fork"></i>03e0cc0</a>
<span class=article-git-commit-subject>fix add displayed_on_home</span>
<span class=article-git-commit-time>2022-11-20 14:49</span>
<a class=article-git-source href=https://github.com/linianhui/blog/blob/main/src/java/unsafe/index.md target=_blank><i class="fa fa-github"></i>源码</a></section></section><section class=article-content><p>Unsafe类是Java提供一个底层的类型，位于<code>sun.misc</code>包中，主要用来提供一些不安全的底层内存操作。</p><blockquote><p>其内部实现在Jdk中略有差异，比如。Jdk 8<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>和Jdk 15<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>的源码。</p></blockquote><h1 id=get-unsafe-object><i id=locator-get-unsafe-object class=header-locator></i>
<a href=#get-unsafe-object class=article-h-a>1 获取Unsafe对象</a></h1><p>由于Unsafe在实现上添加了限制（只能由<code>BootstrapClassLoader</code>加载的类型来调用，而我们的代码通常都是<code>AppClassLoader</code>加载的），所以我们无法直接通过<code>Unsafe.getUnsafe()</code>这个静态方法来获取。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>@CallerSensitive
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>static</span> Unsafe getUnsafe() {
</span></span><span style=display:flex><span>    Class&lt;?&gt; caller = Reflection.getCallerClass();
</span></span><span style=display:flex><span>    <span style=color:#00f>if</span> (!VM.isSystemDomainLoader(caller.getClassLoader()))
</span></span><span style=display:flex><span>        <span style=color:#00f>throw</span> <span style=color:#00f>new</span> SecurityException(<span style=color:#a31515>&#34;Unsafe&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> theUnsafe;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>//VM.isSystemDomainLoader</span>
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>static</span> <span style=color:#2b91af>boolean</span> isSystemDomainLoader(ClassLoader loader) {
</span></span><span style=display:flex><span>  <span style=color:#00f>return</span> loader == <span style=color:#00f>null</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>但是可以通过反射绕过去这个限制:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>static</span> Unsafe getUnsafe() <span style=color:#00f>throws</span> NoSuchFieldException, IllegalAccessException {
</span></span><span style=display:flex><span>    Field theUnsafeField = Unsafe.class.getDeclaredField(<span style=color:#a31515>&#34;theUnsafe&#34;</span>);
</span></span><span style=display:flex><span>    theUnsafeField.setAccessible(<span style=color:#00f>true</span>);
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> (Unsafe) theUnsafeField.get(<span style=color:#00f>null</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=2-unsafe提供的几种操作><i id=locator-2-unsafe提供的几种操作 class=header-locator></i>
<a href=#2-unsafe%e6%8f%90%e4%be%9b%e7%9a%84%e5%87%a0%e7%a7%8d%e6%93%8d%e4%bd%9c class=article-h-a>2 Unsafe提供的几种操作</a></h1><p>大致分为一下几种。</p><h2 id=21-获取字段偏移量><i id=locator-21-获取字段偏移量 class=header-locator></i>
<a href=#21-%e8%8e%b7%e5%8f%96%e5%ad%97%e6%ae%b5%e5%81%8f%e7%a7%bb%e9%87%8f class=article-h-a>2.1 获取字段偏移量</a></h2><p>操作一个对象的某个字段时，偏移量时不可或缺的一个参数。使用它和对象本身来定位指定字段在内存中的位置。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>native</span> <span style=color:#2b91af>long</span> staticFieldOffset(Field f);
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>native</span> <span style=color:#2b91af>long</span> objectFieldOffset(Field f);
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>native</span> Object staticFieldBase(Field f);
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>native</span> <span style=color:#2b91af>int</span> arrayBaseOffset(Class&lt;?&gt; arrayClass);
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>native</span> <span style=color:#2b91af>int</span> arrayIndexScale(Class&lt;?&gt; arrayClass)
</span></span></code></pre></div><h2 id=22-普通读写><i id=locator-22-普通读写 class=header-locator></i>
<a href=#22-%e6%99%ae%e9%80%9a%e8%af%bb%e5%86%99 class=article-h-a>2.2 普通读写</a></h2><p>一下方法可以直接读取和写入一个对象的字段，即使字段是私有的。当然也包含其他的基础类型<code>Byte</code>、<code>Char</code>、<code>Short</code>、<code>Float</code>、<code>Double</code>、<code>Long</code>、<code>Object</code>。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>native</span> <span style=color:#2b91af>int</span> getInt(Object o, <span style=color:#2b91af>long</span> offset);
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>native</span> <span style=color:#2b91af>void</span> putInt(Object o, <span style=color:#2b91af>long</span> offset, <span style=color:#2b91af>int</span> x);
</span></span></code></pre></div><p>也可以直接使用脱离对象本身使用内存地址进行读取和写入。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>native</span> <span style=color:#2b91af>int</span> getInt(<span style=color:#2b91af>long</span> address);
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>native</span> <span style=color:#2b91af>void</span> putInt(<span style=color:#2b91af>long</span> address, <span style=color:#2b91af>int</span> x);
</span></span></code></pre></div><h2 id=23-有序写><i id=locator-23-有序写 class=header-locator></i>
<a href=#23-%e6%9c%89%e5%ba%8f%e5%86%99 class=article-h-a>2.3 有序写</a></h2><p>可以保证写入的有序性，但是无法保证其他线程的可见性。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>native</span> <span style=color:#2b91af>void</span> putOrderedInt(Object o, <span style=color:#2b91af>long</span> offset, <span style=color:#2b91af>int</span> x);
</span></span></code></pre></div><h2 id=24-volatile读写><i id=locator-24-volatile读写 class=header-locator></i>
<a href=#24-volatile%e8%af%bb%e5%86%99 class=article-h-a>2.4 volatile读写</a></h2><p>使用<code>volatile</code>修饰的字段也有专门的方法，可以保证可见性和有序性。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>native</span> <span style=color:#2b91af>int</span> getIntVolatile(Object o, <span style=color:#2b91af>long</span> offset);
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>native</span> <span style=color:#2b91af>void</span> putIntVolatile(Object o, <span style=color:#2b91af>long</span> offset, <span style=color:#2b91af>int</span> x);
</span></span></code></pre></div><h2 id=25-cas操作><i id=locator-25-cas操作 class=header-locator></i>
<a href=#25-cas%e6%93%8d%e4%bd%9c class=article-h-a>2.5 CAS操作</a></h2><p><a href=../juc/cas.md target=_blank rel="noopener norefferrer">CAS</a>的底层实现是完全依赖Unsafe提供的方法的。</p><p>有如下三个基础方法。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>final</span> <span style=color:#00f>native</span> <span style=color:#2b91af>boolean</span> compareAndSwapObject(Object o, <span style=color:#2b91af>long</span> offset,Object expected, Object x);
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>final</span> <span style=color:#00f>native</span> <span style=color:#2b91af>boolean</span> compareAndSwapInt(Object o, <span style=color:#2b91af>long</span> offset,<span style=color:#2b91af>int</span> expected,<span style=color:#2b91af>int</span> x);
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>final</span> <span style=color:#00f>native</span> <span style=color:#2b91af>boolean</span> compareAndSwapLong(Object o, <span style=color:#2b91af>long</span> offset,<span style=color:#2b91af>long</span> expected,<span style=color:#2b91af>long</span> x);
</span></span></code></pre></div><p><a href=../juc/ target=_blank rel="noopener norefferrer">JUC</a>中的原子类，AQS、lock甚至<code>synchronized</code>的底层实现，也都依赖于这些基础CAS方法。<code>ConcurrentHashMap</code>、<code>ConcurrentLinkedQueue</code>等线程安全的容器也都是如此。</p><p>除了上面的3个基础方法外，还有一些包装好的方法。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>final</span> <span style=color:#2b91af>int</span> getAndAddInt(Object o, <span style=color:#2b91af>long</span> offset, <span style=color:#2b91af>int</span> delta) {
</span></span><span style=display:flex><span>    <span style=color:#2b91af>int</span> v;
</span></span><span style=display:flex><span>    <span style=color:#00f>do</span> {
</span></span><span style=display:flex><span>        v = getIntVolatile(o, offset);
</span></span><span style=display:flex><span>    } <span style=color:#00f>while</span> (!compareAndSwapInt(o, offset, v, v + delta));
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> v;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>final</span> <span style=color:#2b91af>int</span> getAndSetInt(Object o, <span style=color:#2b91af>long</span> offset, <span style=color:#2b91af>int</span> newValue) {
</span></span><span style=display:flex><span>    <span style=color:#2b91af>int</span> v;
</span></span><span style=display:flex><span>    <span style=color:#00f>do</span> {
</span></span><span style=display:flex><span>        v = getIntVolatile(o, offset);
</span></span><span style=display:flex><span>    } <span style=color:#00f>while</span> (!compareAndSwapInt(o, offset, v, newValue));
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> v;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以上读写部分等同于C#的<a href=https://docs.microsoft.com/en-us/dotnet/api/system.threading.interlocked target=_blank rel="noopener norefferrer">System.Threading.Interlocked</a>。</p><h2 id=26-类加载><i id=locator-26-类加载 class=header-locator></i>
<a href=#26-%e7%b1%bb%e5%8a%a0%e8%bd%bd class=article-h-a>2.6 类加载</a></h2><p>。。。待续</p><h2 id=27-内存屏障><i id=locator-27-内存屏障 class=header-locator></i>
<a href=#27-%e5%86%85%e5%ad%98%e5%b1%8f%e9%9a%9c class=article-h-a>2.7 内存屏障</a></h2><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green>// 保证在这个屏障之前的所有读操作都已经完成</span>
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>native</span> <span style=color:#2b91af>void</span> loadFence();
</span></span><span style=display:flex><span><span style=color:green>// 保证在这个屏障之前的所有写操作都已经完成</span>
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>native</span> <span style=color:#2b91af>void</span> storeFence();
</span></span><span style=display:flex><span><span style=color:green>// 保证在这个屏障之前的所有读写操作都已经完成</span>
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>native</span> <span style=color:#2b91af>void</span> fullFence();
</span></span></code></pre></div><h2 id=28-线程调度><i id=locator-28-线程调度 class=header-locator></i>
<a href=#28-%e7%ba%bf%e7%a8%8b%e8%b0%83%e5%ba%a6 class=article-h-a>2.8 线程调度</a></h2><p>这部分方法类似于C#的<a href=https://docs.microsoft.com/en-us/dotnet/api/system.threading.monitor target=_blank rel="noopener norefferrer">System.Threading.Monitor</a>。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green>// 挂起线程</span>
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>native</span> <span style=color:#2b91af>void</span> park(<span style=color:#2b91af>boolean</span> isAbsolute, <span style=color:#2b91af>long</span> time);
</span></span><span style=display:flex><span><span style=color:green>// 唤醒线程</span>
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>native</span> <span style=color:#2b91af>void</span> unpark(Object thread);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// synchronized的底层实现基于此，不过目前以及标记为弃用了。</span>
</span></span><span style=display:flex><span>@Deprecated
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>native</span> <span style=color:#2b91af>void</span> monitorEnter(Object o);
</span></span><span style=display:flex><span>@Deprecated
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>native</span> <span style=color:#2b91af>void</span> monitorExit(Object o);
</span></span><span style=display:flex><span>@Deprecated
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>native</span> <span style=color:#2b91af>boolean</span> tryMonitorEnter(Object o);
</span></span></code></pre></div><p>其中<code>pack</code>、<code>uppack</code>以及是<code>LockSupport</code>的基础。而<code>LockSupport</code>是<code>AQS</code>的基础。<code>AQS</code>则是<a href=https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/package-summary.html target=_blank rel="noopener norefferrer">java.util.concurrent.locks</a>包的基础抽象类。</p><p><code>pack</code>的参数<code>isAbsolute</code>为<code>true</code>是表示time是绝对时间，单位是<code>毫秒</code>。为<code>false</code>是表示为相对时间，单位是<code>纳秒</code>。比如如下是等价的。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green>// TIMED_WAITING 相对时间，100毫秒</span>
</span></span><span style=display:flex><span>unsafe.pack(<span style=color:#00f>false</span>, 100*1000*1000));
</span></span><span style=display:flex><span><span style=color:green>// TIMED_WAITING 绝对时间，100毫秒</span>
</span></span><span style=display:flex><span>unsafe.pack(<span style=color:#00f>true</span>, System.currentTimeMillis()+100));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// WAITING 一致阻塞，直到调用unpack</span>
</span></span><span style=display:flex><span>unsafe.pack(<span style=color:#00f>false</span>, 0L));
</span></span></code></pre></div><h1 id=3-参考资料><i id=locator-3-参考资料 class=header-locator></i>
<a href=#3-%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99 class=article-h-a>3 参考资料</a></h1><p>Java中的Unsafe ：<a href=https://www.jianshu.com/p/db8dce09232d target=_blank rel="noopener norefferrer">https://www.jianshu.com/p/db8dce09232d</a></p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>JDK8中的<code>sun.misc.Unsafe</code> : <a href=http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/sun/misc/Unsafe.java target=_blank rel="noopener norefferrer">http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/sun/misc/Unsafe.java</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>JDK15中的<code>sun.misc.Unsafe</code> : <a href=https://github.com/openjdk/jdk15/blob/master/src/jdk.unsupported/share/classes/sun/misc/Unsafe.java target=_blank rel="noopener norefferrer">https://github.com/openjdk/jdk15/blob/master/src/jdk.unsupported/share/classes/sun/misc/Unsafe.java</a>，内部是使用<code>jdk.internal.misc.Unsafe</code>:<a href=https://github.com/openjdk/jdk15/blob/master/src/java.base/share/classes/jdk/internal/misc/Unsafe.java target=_blank rel="noopener norefferrer">https://github.com/openjdk/jdk15/blob/master/src/java.base/share/classes/jdk/internal/misc/Unsafe.java</a>来实现，等同于JDK8。&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></section><section class=article-meta><section class=article-date>2020-11-04 19:32，约1710字，阅读约4分钟</section><section class=article-topics><a class=article-topic href=/java/ title=[Java] target=_blank><i class="fa fa-folder"></i>[Java]</a></section><section class=article-tags><a class=article-tag href=/tag/java target=_blank><i class="fa fa-tag"></i>Java</a>
<a class=article-tag href=/tag/unsafe target=_blank><i class="fa fa-tag"></i>Unsafe</a></section><section class=article-git><a class=article-git-commit href=https://github.com/linianhui/blog/commit/03e0cc08866458647d96951c1817c624518149d6 target=_blank><i class="fa fa-code-fork"></i>03e0cc0</a>
<span class=article-git-commit-subject>fix add displayed_on_home</span>
<span class=article-git-commit-time>2022-11-20 14:49</span>
<a class=article-git-source href=https://github.com/linianhui/blog/blob/main/src/java/unsafe/index.md target=_blank><i class="fa fa-github"></i>源码</a></section></section><section class=article-page><div class=article-page-prev><span>上一篇 : </span><a href=/java/jvm/ target=_blank>[Java] JVM(Java Virtual Machine)</a></div><div class=article-page-next><span>下一篇 : </span><a href=/java/jmm/ target=_blank>[Java] JMM(Java Memory Model)</a></div></section></article><section id=article-comment class=article-comment><script src=https://utteranc.es/client.js repo=linianhui/blog issue-term=pathname label=blog-comment theme=github-light crossorigin=anonymous async></script></section></main><footer class=footer><section>Copyright © 2025 by <a href=https://github.com/linianhui/blog target=_blank>Timetombs</a></section><section><a class=article-git-commit href=https://github.com/linianhui/blog/commit/2fac07e818d6d4ad6b78781efea82c28769c8c02 target=_blank><i class="fa fa-code-fork"></i>2fac07e</a>
Powered by
<a href=https://github.com/actions target=_blank>GitHub Actions</a>
,
<a href=https://github.com/gohugoio/hugo target=_blank>Hugo</a>
and
<a href=https://github.com/utterance/utterances target=_blank>utterances</a>
Hosted on <a href=https://pages.github.com/ target=_blank>GitHub Pages</a><section></footer></main><aside class=toolbar><a class="fa fa-list" href=javascript:blog.toggleToc(); title=目录></a><a class="fa fa-comments" href=#article-comment title=评论></a><a class="fa fa-arrow-up" href=javascript:scroll(0,0); title=返回顶部></a></aside><script type=text/javascript>var _hmt=_hmt||[];blog.addOnScorllEvent()</script><script src=https://hm.baidu.com/hm.js?b2cc3cea316e1f7a8def1bab8dc98fad async></script></body></html>