<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=google-site-verification content="X6gTMGCy1-_vb5i3aja3ZZyzPY3raiKRJp4VIhOAX24"><meta name=msvalidate.01 content="CDE7502649B75529BD0FCFE89B056E38"><title>[Java] JVM(Java Virtual Machine) - Timetombs</title>
<link rel=icon type=image/svg href=/favicon.svg><link rel=stylesheet href=https://s4.zstatic.net/ajax/libs/normalize/8.0.1/normalize.min.css crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://s4.zstatic.net/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css crossorigin=anonymous referrerpolicy=no-referrer><link href='/asset/blog.css?time=2025-10-26T19%3a03%3a29Z%2b08%3a00' rel=stylesheet type=text/css><script src=https://s4.zstatic.net/npm/currency.js@2.0.4/dist/currency.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://s4.zstatic.net/ajax/libs/moment.js/2.30.1/moment.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src='/asset/blog.js?time=2025-10-26T19%3a03%3a29Z%2b08%3a00' type=application/javascript></script><script type=text/javascript>blog.isMobile()&&document.write('<link href="/asset/blog.mobile.css?time=2025-10-26T19%3A03%3A29Z%2B08%3A00" rel="stylesheet">')</script></head><body><div id=horizontal-progress class=horizontal-progress></div><aside id=toc class=toc><section class=toc-header><a class=toc-page-title href=/java/ target=_blank>[Java]</a></section><section class=toc-page><a class=toc-page-title href=/java/install/ target=_blank>[Java] Install</a></section><section class="toc-page selected"><span class=toc-page-title>[Java] JVM(Java Virtual Machine)</span><nav id=TableOfContents><ul><li><a href=#date-type>1 Data Type</a><ul><li><a href=#primitive-type>1.1 Primitive Type</a></li><li><a href=#reference-type>1.2 Reference Type</a></li></ul></li><li><a href=#compiling>2 Compiling</a><ul><li><a href=#this-argument>2.1 this Argument</a></li><li><a href=#synchronization>2.2 Synchronization</a></li></ul></li><li><a href=#runtime-data-areas>3 Runtime Data Areas</a><ul><li><a href=#program-counter>3.1 Program Counter</a></li><li><a href=#jvm-stack>3.2 JVM Stack</a></li><li><a href=#heap>3.3 Heap</a></li><li><a href=#methad-area>3.4 Methad Area</a></li><li><a href=#native-method-stack>3.5 Native Method Stack</a></li><li><a href=#direct-memory>3.6 Direct Memory</a></li><li><a href=#memory-allocation>3.7 Memory Allocation</a></li></ul></li><li><a href=#class-file-format>4 Class File Format</a></li><li><a href=#loading-linking-and-initializing>5 Loading Linking and Initializing</a></li><li><a href=#options>6 JVM Options</a></li><li><a href=#reference>7 参考资料</a></li></ul></nav></section><section class=toc-page><a class=toc-page-title href=/java/tool/ target=_blank>[Java] Tool</a></section><section class=toc-page><a class=toc-page-title href=/java/unsafe/ target=_blank>[Java] Unsafe类</a></section><section class=toc-page><a class=toc-page-title href=/java/jmm/ target=_blank>[Java] JMM(Java Memory Model)</a></section><section class=toc-page><a class=toc-page-title href=/java/gc/ target=_blank>[Java] GC(Garbage Collection)</a></section><section class=toc-page><a class=toc-page-title href=/java/thread/ target=_blank>[Java] Thread</a></section><section class=toc-page><a class=toc-page-title href=/java/cas/ target=_blank>[Java] CAS(Compare And Swap)</a></section><section class=toc-page><a class=toc-page-title href=/java/synchronized/ target=_blank>[Java] synchronized</a></section><script type=text/javascript>blog.isPC()&&blog.toggleToc()</script></aside><main class=main><header class=header><hgroup class=header-hgroup><h1 class=header-hgroup-title><a href=/>Timetombs</a></h1><h2 class=header-hgroup-subtitle>泛义的工具是文明的基础，而确指的工具却是愚人的器物</h2></hgroup><nav class=header-nav><a class=header-nav-item href=/topic/ title=专题 target=_self><i class="fa fa-folder"></i>专题</a>
<a class=header-nav-item href=/tag/ title=标签 target=_self><i class="fa fa-tags"></i>标签</a>
<a class=header-nav-item href=/archive/ title=归档 target=_self><i class="fa fa-archive"></i>归档</a>
<a class=header-nav-item href=https://linianhui.cnblogs.com title=博客园 target=_black><img src=/asset/cnblogs.favicon.svg>博客园</a>
<a class=header-nav-item href=https://github.com/linianhui/blog title=GitHub target=_black><i class="fa fa-github"></i>GitHub</a></nav><div class=header-stats><div class=stats><span>共
<i>66<sub>h</sub>
</i>/
<i>118<sub>a</sub>
</i>篇</span><div class=stats-date>，更新于 2025-10-26T19:03:29Z+08:00 by &nbsp;
<a class=git-commit href=https://github.com/linianhui/blog/commit/2fac07e818d6d4ad6b78781efea82c28769c8c02 target=_blank><i class="fa fa-code-fork"></i>2fac07e</a></div></div><form class=search method=GET target=_blank action=https://www.bing.com/search><input name=q class=search-input type=search placeholder=search... results=5 onkeypress="search_param.value=search_param_site.value+this.value">
<input id=search_param_site type=hidden value="site:linianhui.github.io ">
<input name=q id=search_param type=hidden></form></div></header><main class=content><article class=article><h1 class=article-title>[Java] JVM(Java Virtual Machine)</h1><div class=article-copyright><span>版权声明 - </span><a href=/copyright/cc target=_blank>CC BY-NC-SA 4.0</a></div><section class=article-meta><section class=article-date>2020-03-04 19:32，约4569字，阅读约10分钟</section><section class=article-topics><a class=article-topic href=/java/ title=[Java] target=_blank><i class="fa fa-folder"></i>[Java]</a></section><section class=article-tags><a class=article-tag href=/tag/docker target=_blank><i class="fa fa-tag"></i>Docker</a>
<a class=article-tag href=/tag/java target=_blank><i class="fa fa-tag"></i>Java</a>
<a class=article-tag href=/tag/jvm target=_blank><i class="fa fa-tag"></i>JVM</a></section><section class=article-git><a class=article-git-commit href=https://github.com/linianhui/blog/commit/03e0cc08866458647d96951c1817c624518149d6 target=_blank><i class="fa fa-code-fork"></i>03e0cc0</a>
<span class=article-git-commit-subject>fix add displayed_on_home</span>
<span class=article-git-commit-time>2022-11-20 14:49</span>
<a class=article-git-source href=https://github.com/linianhui/blog/blob/main/src/java/jvm/index.md target=_blank><i class="fa fa-github"></i>源码</a></section></section><section class=article-content><p>Java是一个跨平台的语言，当初的口号<strong>编译一次，到处运行</strong>。那么它是如何实现跨平台运行的呢？计算机领域有个有个著名的定理<strong>中间层定律</strong>：计算机科学领域的任何问题都可以通过增加一个中间层来解决。那么Java的跨平台也不例外，它就是通过添加了一个中间层来解决跨平台运行的问题的。</p><p>我们知道计算机是无法直接运行我们编写的程序设计语言<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>的代码的，需要编译为计算机可理解的特定底层汇编或者机器码指令才可以。所以Java从诞生之初就没有编译成平台相关的代码，而是编译为了平台无关的<code>bytecode</code>字节码（文件扩展名<code>.class</code>）。然后交由Java虚拟机JVM(Java Virtual Machine)来执行字节码文件，而JVM则需要在每个支持的平台上独立的编写，由它充当我们的<strong>中间层</strong>，以此达到我们编写的代码跨平台运行的目的。</p><p>故而，我们编写的Java代码从面向特定的平台而转换为了编写JVM平台。JVM<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>来负责加载编译后的<code>.class</code>文件、并且执行它们，它就是我们Java代码运行的一个假象计算机。</p><h1 id=date-type><i id=locator-date-type class=header-locator></i>
<a href=#date-type class=article-h-a>1 Data Type</a></h1><p>JVM支持两种数据类型<code>Primitive Type</code>和<code>Reference Type</code>，这两种类型都是Java语言的一等公民<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>。</p><p>不管是那种类型，Java中调用方法传参时都是采用的值传递的方式：<code>Primitive Type</code>传递的时值的副本；<code>Reference Type</code>传递的是引用的副本。</p><h2 id=primitive-type><i id=locator-primitive-type class=header-locator></i>
<a href=#primitive-type class=article-h-a>1.1 Primitive Type</a></h2><p>JVM支持的<code>Primitive Type</code>有三种：<code>numeric</code>、<code>boolean</code>、<code>returnAddress</code>。</p><table><thead><tr><th>type</th><th>bits</th><th>default value</th></tr></thead><tbody><tr><td>byte</td><td>8</td><td>0</td></tr><tr><td>short</td><td>16</td><td>0</td></tr><tr><td>char</td><td>16</td><td>0</td></tr><tr><td>int</td><td>32</td><td>0</td></tr><tr><td>long</td><td>64</td><td>0</td></tr><tr><td>float</td><td>32</td><td>0</td></tr><tr><td>double</td><td>64</td><td>0</td></tr><tr><td>boolean</td><td>8</td><td>false</td></tr></tbody></table><p>JVM没有对<code>boolean</code>类型定义专门的操作指令,而是使用<code>int</code>的指令进行操作的。当使用<code>boolean[]</code>时，HotSpot虚拟机会把它映射为<code>byte[]</code>，这时每一个元素占据8bit。编译器也可以直接把<code>boolean</code>类型的字段映射为<code>int</code>类型，这时它占据32bit。</p><p><code>returnAddress</code>类型被JVM的<code>jsr</code>、<code>ret</code>和<code>jsr_w</code>指令所使用，它的值是指向JVM指令操作码的指针。与上述的其他类型不同的是这时编译器所使用的，Java语言层面接触不到它。</p><h2 id=reference-type><i id=locator-reference-type class=header-locator></i>
<a href=#reference-type class=article-h-a>1.2 Reference Type</a></h2><p>JVM支持的<code>Reference Type</code>也有三种：<code>class</code>、<code>array</code>、<code>interface</code>。分别对应着类实例、数组实例和接口引用。引用类型的默认值是<code>null</code>，<code>null</code>可以转换为任意的引用类型，但是转换后还是<code>null</code>。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green>// str还是null，但是类型转换不会失败和抛出异常。</span>
</span></span><span style=display:flex><span>String str = (String)<span style=color:#00f>null</span>;
</span></span></code></pre></div><h1 id=compiling><i id=locator-compiling class=header-locator></i>
<a href=#compiling class=article-h-a>2 Compiling</a></h1><p>HotSpot虚拟机包含一个java编译器<strong>javac</strong>，负责把我们编写的Java源码编译为JVM可理解的指令集(<code>*.class</code>文件)。</p><h2 id=this-argument><i id=locator-this-argument class=header-locator></i>
<a href=#this-argument class=article-h-a>2.1 this Argument</a></h2><p>Java是一个面向对象的语言，在方法调用上与面向过程的语言一个显著的区别，那就是编译器会自动的为实例方法安插<code>this</code>引用(指针)这个参数<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>。比如如下的一个实例方法：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#2b91af>int</span> add12and13() {
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> addTwo(2, 3);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// 编译后</span>
</span></span><span style=display:flex><span>Method <span style=color:#2b91af>int</span> add12and13()
</span></span><span style=display:flex><span>0   aload_0             <span style=color:green>// Push local variable 0 (this)</span>
</span></span><span style=display:flex><span>1   bipush 2            <span style=color:green>// Push int constant 2</span>
</span></span><span style=display:flex><span>3   bipush 3            <span style=color:green>// Push int constant 3</span>
</span></span><span style=display:flex><span>5   invokevirtual <span>#</span>4    <span style=color:green>// Method Example.addtwo(II)I</span>
</span></span><span style=display:flex><span>8   ireturn             <span style=color:green>// Return int on top of operand stack;</span>
</span></span><span style=display:flex><span>                        <span style=color:green>// it is the int result of addTwo()</span>
</span></span></code></pre></div><p>在调用<code>addTwo(2,3)</code>方法是，隐含的代码是通过<code>this.addTwo(2,3)</code>来调用的，所以第一个指令<code>aload_0</code>的含义就是加载<code>this</code>这个引用。当然如果这个方法内没有使用到<code>this</code>时，就不会生成这个<code>aload_0</code>的指令了。</p><p>如果<code>addTwo</code>方法是静态方法时，也是不需要this的。</p><h2 id=synchronization><i id=locator-synchronization class=header-locator></i>
<a href=#synchronization class=article-h-a>2.2 Synchronization</a></h2><p>如果一个方法是用<code>synchronized</code>标记的<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>，那么这个方法的的访问修饰符标记上就会添加一项<code>ACC_SYNCHRONIZED</code>。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>synchronized</span> <span style=color:#2b91af>void</span> onlyMe() {
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// javap -p xxx.class</span>
</span></span><span style=display:flex><span><span style=color:#00f>synchronized</span> <span style=color:#2b91af>void</span> onlyMe();
</span></span><span style=display:flex><span>  descriptor: ()V
</span></span><span style=display:flex><span>  flags: ACC_SYNCHRONIZED
</span></span><span style=display:flex><span>  Code:
</span></span><span style=display:flex><span>    stack=0, locals=1, args_size=1
</span></span><span style=display:flex><span>        0: <span style=color:#00f>return</span>
</span></span><span style=display:flex><span>    LineNumberTable:
</span></span><span style=display:flex><span>      line 3: 0
</span></span></code></pre></div><p>如果是用<code>synchronized(obj)</code>，编译器则会安插进去一些额外的指令<code>monitorenter</code>和<code>monitorexit</code>,来指示JVM如何加锁和释放锁。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#2b91af>void</span> onlyMe(Foo f) {
</span></span><span style=display:flex><span>    <span style=color:#00f>synchronized</span>(f) {
</span></span><span style=display:flex><span>        doSomething();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// 编译后</span>
</span></span><span style=display:flex><span>Method <span style=color:#2b91af>void</span> onlyMe(Foo)
</span></span><span style=display:flex><span>0   aload_1             <span style=color:green>// Push f</span>
</span></span><span style=display:flex><span>1   dup                 <span style=color:green>// Duplicate it on the stack</span>
</span></span><span style=display:flex><span>2   astore_2            <span style=color:green>// Store duplicate in local variable 2</span>
</span></span><span style=display:flex><span>3   monitorenter        <span style=color:green>// Enter the monitor associated with f</span>
</span></span><span style=display:flex><span>4   aload_0             <span style=color:green>// Holding the monitor, pass this and...</span>
</span></span><span style=display:flex><span>5   invokevirtual <span>#</span>5    <span style=color:green>// ...call Example.doSomething()V</span>
</span></span><span style=display:flex><span>8   aload_2             <span style=color:green>// Push local variable 2 (f)</span>
</span></span><span style=display:flex><span>9   monitorexit         <span style=color:green>// Exit the monitor associated with f</span>
</span></span><span style=display:flex><span>10  <span style=color:#00f>goto</span> 18             <span style=color:green>// Complete the method normally</span>
</span></span><span style=display:flex><span>13  astore_3            <span style=color:green>// In case of any throw, end up here</span>
</span></span><span style=display:flex><span>14  aload_2             <span style=color:green>// Push local variable 2 (f)</span>
</span></span><span style=display:flex><span>15  monitorexit         <span style=color:green>// Be sure to exit the monitor!</span>
</span></span><span style=display:flex><span>16  aload_3             <span style=color:green>// Push thrown value...</span>
</span></span><span style=display:flex><span>17  athrow              <span style=color:green>// ...and rethrow value to the invoker</span>
</span></span><span style=display:flex><span>18  <span style=color:#00f>return</span>              <span style=color:green>// Return in the normal case</span>
</span></span><span style=display:flex><span>Exception table:
</span></span><span style=display:flex><span>From    To      Target      Type
</span></span><span style=display:flex><span>4       10      13          any
</span></span><span style=display:flex><span>13      16      13          any
</span></span></code></pre></div><h1 id=runtime-data-areas><i id=locator-runtime-data-areas class=header-locator></i>
<a href=#runtime-data-areas class=article-h-a>3 Runtime Data Areas</a></h1><p>JVM定义了一些在程序执行期间使用的各种运行时数据区域。其中一些区域是随着Java虚拟机启动而创建的，只有在Java虚拟机退出时才会销毁。而其他的一些区域则是随着线程的创建而创建，在随着线程的退出而销毁。</p><h2 id=program-counter><i id=locator-program-counter class=header-locator></i>
<a href=#program-counter class=article-h-a>3.1 Program Counter</a></h2><p>JVM支持多线程，每个线程创建后，都有它自己的PC计数器(program counter)，伴随着线程的创建和结束。</p><p>PC记录着当前线程的代码执行的位置（非native代码），当线程中断、阻塞或者让出CPU时间片后可以利用它来恢复到之前的执行点。</p><h2 id=jvm-stack><i id=locator-jvm-stack class=header-locator></i>
<a href=#jvm-stack class=article-h-a>3.2 JVM Stack</a></h2><p>每个线程创建后，都有它自己的栈内存区域，伴随着线程的创建和结束。</p><p>Java的线程<code>1:1</code>映射到OS的线程。linux的每个线程默认的栈大小为<code>8MB</code>，Java的线程默认大小为<code>1MB</code>。栈中存放时的是栈帧Frame。当栈大小固定时，如果没有足够的空间存放栈帧Frame了，那么就会抛出<code>StackOverflowError</code>。当栈大小是非固定时，则会抛出<code>OutOfMemoryError</code>。</p><p>每一个方法执行时就会创建一个栈帧Frame，随着方法的执行完毕而退出，都包含如下部分。</p><ol><li>局部变量表</li><li>操作数栈</li><li>动态连接</li><li>返回地址</li><li>异常处理</li></ol><h2 id=heap><i id=locator-heap class=header-locator></i>
<a href=#heap class=article-h-a>3.3 Heap</a></h2><p>JVM中只有一个堆，伴随着JVM的启动和结束，所有线程共享此部分数据区域。</p><p>对象和数组的数据分配在此区域中。堆中的数据不会显示的释放，而是由GC负责回收。堆的大小可以时固定的，也可以时动态扩展的，这和具体的GC收集器有关。</p><p>如果堆内存不足，则会抛出<code>OutOfMemoryError</code>。</p><h2 id=methad-area><i id=locator-methad-area class=header-locator></i>
<a href=#methad-area class=article-h-a>3.4 Methad Area</a></h2><p>JVM中只有一个方法区，伴随着JVM的启动和结束，所有线程共享此部分数据区域。</p><p>class文件、运行时常量、静态字段、代码等存放在此区域。大小也是可以固定或者动态扩展。GC可以自由选择是否回收此区域。</p><p>如果内存不足，也会抛出<code>OutOfMemoryError</code>。</p><h2 id=native-method-stack><i id=locator-native-method-stack class=header-locator></i>
<a href=#native-method-stack class=article-h-a>3.5 Native Method Stack</a></h2><p>在调用本地方法时，需要JVM分配本地方法栈内存区域。它和JVM栈类似，也是伴随着线程的创建和销毁。有可以固定大小和动态大小，内存不足时抛出<code>StackOverflowError</code>或者<code>OutOfMemoryError</code>。</p><h2 id=direct-memory><i id=locator-direct-memory class=header-locator></i>
<a href=#direct-memory class=article-h-a>3.6 Direct Memory</a></h2><p>严格来说，这部分不属于JVM管理的内存数据区域。1.4 NIO引入后，基于缓冲区的I/O。直接在堆外分配内存，然后通过DirectByteBuffer这个引用操作堆外内存。</p><h2 id=memory-allocation><i id=locator-memory-allocation class=header-locator></i>
<a href=#memory-allocation class=article-h-a>3.7 Memory Allocation</a></h2><ol><li>TLAB(Thread Local Allocation Buffer)</li><li>堆</li><li>栈</li></ol><h1 id=class-file-format><i id=locator-class-file-format class=header-locator></i>
<a href=#class-file-format class=article-h-a>4 Class File Format</a></h1><p>笔者之前用Rust语言编写过一个class文件的解析器<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>(还未完工)。在编写的过程中对字节码又了更进一步的理解。字节码其实就是我们编写的java代码，只是它是基于栈的一种类似汇编语言的二进制格式。JVM规范中规定了这个二进制文件的结构。一个完整的Class文件结构如下（采用大端/网络字节序存储）：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>ClassFile {
</span></span><span style=display:flex><span>    u4             magic;
</span></span><span style=display:flex><span>    u2             minor_version;
</span></span><span style=display:flex><span>    u2             major_version;
</span></span><span style=display:flex><span>    u2             constant_pool_count;
</span></span><span style=display:flex><span>    cp_info        constant_pool[constant_pool_count-1];
</span></span><span style=display:flex><span>    u2             access_flags;
</span></span><span style=display:flex><span>    u2             this_class;
</span></span><span style=display:flex><span>    u2             super_class;
</span></span><span style=display:flex><span>    u2             interfaces_count;
</span></span><span style=display:flex><span>    u2             interfaces[interfaces_count];
</span></span><span style=display:flex><span>    u2             fields_count;
</span></span><span style=display:flex><span>    field_info     fields[fields_count];
</span></span><span style=display:flex><span>    u2             methods_count;
</span></span><span style=display:flex><span>    method_info    methods[methods_count];
</span></span><span style=display:flex><span>    u2             attributes_count;
</span></span><span style=display:flex><span>    attribute_info attributes[attributes_count];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol><li><code>magic</code> : 文件魔数,标识此文件是一个class文件，固定值: 0xCA_FE_BA_BE。</li><li><code>minor_version</code>：次版本号，</li><li><code>major_version</code>：主版本号，比如Java 8是52，版本号标识着JVM支持的规范的版本，以及Class文件的结构。</li><li><code>constant_pool_count</code>：常量池元素数量</li><li><code>constant_pool[constant_pool_count-1]</code>：常量池数组, 索引从1开始，0代表无效的。</li><li><code>access_flags</code>：类的访问标识符，比如:是否public,interface,abstract等等</li><li><code>this_class</code>：当前类符号信息在常量池中的索引</li><li><code>super_class</code>：父类符号信息在常量池中的索引</li><li><code>interfaces_count</code>：实现的接口的数量。</li><li><code>interfaces[interfaces_count]</code>：接口的数组，数组中的元素也是指向常量池中的索引。</li><li><code>fields_count</code>：字段的数量。</li><li><code>fields[fields_count]</code>: 字段信息的数组。</li><li><code>methods_count</code>：方法的数量。</li><li><code>methods[methods_count]</code>: 方法信息的数组。</li><li><code>attributes_count</code>：attribute的数量。</li><li><code>attributes[attributes_count]</code>: attribute信息的数组。</li></ol><p>其中field,method,attribute这些数组中的信息记录着的也是指向<code>constant_pool</code>的索引。除此之外是<code>attributes</code>这个数组，我们的代码最终是体现在这里的（也包括我们的代码行号等信息）。这个文件结构是Java得以跨平台的根基。更详细的信息就不展开了，具体细节可以参考JVM规范<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>和上面提到的我编写的一个解析器。</p><h1 id=loading-linking-and-initializing><i id=locator-loading-linking-and-initializing class=header-locator></i>
<a href=#loading-linking-and-initializing class=article-h-a>5 Loading Linking and Initializing</a></h1><p>有了<code>*.class</code>文件，那么JVM就负责转载，解析，并且执行它。加载由ClassLoader来负责，Java中有三类ClassLoader。</p><ol><li>BootstrapClassLoader : 由c++编写，复杂加载Java的核心类库。</li><li>ExtClassLoader : Java编写，负责加载Java的扩展类库。</li><li>AppClassLoader : Java编写，负责应用程序成名的类。</li></ol><p>ClassLoader采用双亲委派的模型来装载class文件。即先用父类加载器去加载，加载不到时才让自己加载。<br><img src=class-loader.png loading=lazy decoding=auto alt=ClassLoader加载顺序 title=ClassLoader加载顺序></p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>graph TB
    ExtClassLoader --委托--&gt; BootstrapClassLoader
    AppClassLoader --委托--&gt; ExtClassLoader
    CustomClassLoader1 --继承--&gt; AppClassLoader
    CustomClassLoader2 --继承--&gt; AppClassLoader
</code></pre><p>这样做可以有一下好处：</p><ol><li>避免重复加载某些类型。</li><li>避免核心类型不被随意替换。</li></ol><p>一个class文件的完整生命周期如下：<br><img src=class-loader-life-cycle.png loading=lazy decoding=auto alt=class文件的完整生命周期 title=class文件的完整生命周期></p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>graph LR
    加载Loading --&gt; 验证Verification
    验证Verification --&gt; 准备Preparation
    准备Preparation --&gt; 解析Resolution
    解析Resolution --&gt; 初始化Initialization
    初始化Initialization --&gt; 使用Using
    使用Using --&gt; 卸载Unloading
</code></pre><ol><li>加载: 从磁盘文件或者网络中得到class文件的二进制数据，生成一个<code>java.lang.Class</code>文件。</li><li>验证：检查Class是否符合当前虚拟机的要求，有没有危害。</li><li>准备：为类变量分配内存。在方法区给这些变量分配内存并且设置零值。</li><li>解析：把常量池中的符号引用替换成直接引用。</li><li>初始化：执行编译时自动生成的类的构造器方法<code>&lt;clinit>()</code>，为静态变量赋值。</li><li>使用：至此就可以使用这个class了。</li><li>卸载：不再使用时，可以卸载此class。</li></ol><p>JVM执行class时分两种情况：</p><ol><li>解释执行</li><li>热点代码经过JIT编译为本机代码直接执行。</li></ol><h1 id=options><i id=locator-options class=header-locator></i>
<a href=#options class=article-h-a>6 JVM Options</a></h1><table><thead><tr><th style=text-align:left>name</th><th style=text-align:left>JEP</th><th style=text-align:left>version</th><th style=text-align:left>usage</th></tr></thead><tbody><tr><td style=text-align:left>-XX:+PrintFlagsFinal</td><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left>打印最终生效的Options</td></tr><tr><td style=text-align:left>-XX:+UnlockExperimentalVMOptions</td><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left>启用实验性的Options</td></tr><tr><td style=text-align:left>-XX:+UnlockDiagnosticVMOptions</td><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left>启用诊断性的Options</td></tr><tr><td style=text-align:left>-XX:+UseG1GC</td><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left>GC : 启用G1</td></tr><tr><td style=text-align:left>-XX:+UseContainerSupport</td><td style=text-align:left></td><td style=text-align:left>8 <a href=https://www.oracle.com/technetwork/java/javase/8u191-relnotes-5032181.html target=_blank rel="noopener norefferrer">8u191</a></td><td style=text-align:left>JVM: 启用容器支持（自动感知容器的cpu和memory限制）</td></tr><tr><td style=text-align:left>-XX:MaxRAMPercentage</td><td style=text-align:left></td><td style=text-align:left>8 <a href=https://www.oracle.com/technetwork/java/javase/8u191-relnotes-5032181.html target=_blank rel="noopener norefferrer">8u191</a></td><td style=text-align:left>JVM: Heap可使用的最大内存比例</td></tr><tr><td style=text-align:left>-XX:ParallelGCThreads</td><td style=text-align:left><a href=https://openjdk.java.net/jeps/307 target=_blank rel="noopener norefferrer">JEP-307</a></td><td style=text-align:left>10</td><td style=text-align:left>GC : G1改进,允许设置并行GC线程数</td></tr><tr><td style=text-align:left>-XX:G1PeriodicGCInterval</td><td style=text-align:left><a href=https://openjdk.java.net/jeps/346 target=_blank rel="noopener norefferrer">JEP-346</a></td><td style=text-align:left>12</td><td style=text-align:left>GC : G1改进,在空闲时自动将Java堆内存返还给操作系统。</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>java -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+PrintFlagsFinal -version
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green># 开启容器支持，并且设置最大内存占用为容器上限的75%。</span>
</span></span><span style=display:flex><span>java -XX:+UseG1GC -XX:+UseContainerSupport -XX:MaxRAMPercentage=75.00 -jar app.jar
</span></span></code></pre></div><h1 id=reference><i id=locator-reference class=header-locator></i>
<a href=#reference class=article-h-a>7 参考资料</a></h1><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>程序设计语言：<a href=https://linianhui.github.io/programming-language/ target=_blank rel="noopener norefferrer">https://linianhui.github.io/programming-language/</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Java® Virtual Machine Specification : <a href=https://docs.oracle.com/javase/specs/jvms/se8/html/index.html target=_blank rel="noopener norefferrer">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>First-class citizen : <a href=https://en.wikipedia.org/wiki/First-class_citizen target=_blank rel="noopener norefferrer">https://en.wikipedia.org/wiki/First-class_citizen</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>JVMS - Chapter 3. Compiling for the Java Virtual Machine - this Argument : <a href=https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html#jvms-3.7 target=_blank rel="noopener norefferrer">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html#jvms-3.7</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>JVMS - Chapter 3. Compiling for the Java Virtual Machine - Synchronization : <a href=https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html#jvms-3.14 target=_blank rel="noopener norefferrer">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html#jvms-3.14</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>class file 解析器 : <a href=https://github.com/linianhui/div/tree/master/src/class target=_blank rel="noopener norefferrer">https://github.com/linianhui/div/tree/master/src/class</a>&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p>JVMS - Chapter 4. The class File Format : <a href=https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html target=_blank rel="noopener norefferrer">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a>&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></section><section class=article-meta><section class=article-date>2020-03-04 19:32，约4569字，阅读约10分钟</section><section class=article-topics><a class=article-topic href=/java/ title=[Java] target=_blank><i class="fa fa-folder"></i>[Java]</a></section><section class=article-tags><a class=article-tag href=/tag/docker target=_blank><i class="fa fa-tag"></i>Docker</a>
<a class=article-tag href=/tag/java target=_blank><i class="fa fa-tag"></i>Java</a>
<a class=article-tag href=/tag/jvm target=_blank><i class="fa fa-tag"></i>JVM</a></section><section class=article-git><a class=article-git-commit href=https://github.com/linianhui/blog/commit/03e0cc08866458647d96951c1817c624518149d6 target=_blank><i class="fa fa-code-fork"></i>03e0cc0</a>
<span class=article-git-commit-subject>fix add displayed_on_home</span>
<span class=article-git-commit-time>2022-11-20 14:49</span>
<a class=article-git-source href=https://github.com/linianhui/blog/blob/main/src/java/jvm/index.md target=_blank><i class="fa fa-github"></i>源码</a></section></section><section class=article-page><div class=article-page-prev><span>上一篇 : </span><a href=/java/tool/ target=_blank>[Java] Tool</a></div><div class=article-page-next><span>下一篇 : </span><a href=/java/unsafe/ target=_blank>[Java] Unsafe类</a></div></section></article><section id=article-comment class=article-comment><script src=https://utteranc.es/client.js repo=linianhui/blog issue-term=pathname label=blog-comment theme=github-light crossorigin=anonymous async></script></section></main><footer class=footer><section>Copyright © 2025 by <a href=https://github.com/linianhui/blog target=_blank>Timetombs</a></section><section><a class=article-git-commit href=https://github.com/linianhui/blog/commit/2fac07e818d6d4ad6b78781efea82c28769c8c02 target=_blank><i class="fa fa-code-fork"></i>2fac07e</a>
Powered by
<a href=https://github.com/actions target=_blank>GitHub Actions</a>
,
<a href=https://github.com/gohugoio/hugo target=_blank>Hugo</a>
and
<a href=https://github.com/utterance/utterances target=_blank>utterances</a>
Hosted on <a href=https://pages.github.com/ target=_blank>GitHub Pages</a><section></footer></main><aside class=toolbar><a class="fa fa-list" href=javascript:blog.toggleToc(); title=目录></a><a class="fa fa-comments" href=#article-comment title=评论></a><a class="fa fa-arrow-up" href=javascript:scroll(0,0); title=返回顶部></a></aside><script type=text/javascript>var _hmt=_hmt||[];blog.addOnScorllEvent()</script><script src=https://hm.baidu.com/hm.js?b2cc3cea316e1f7a8def1bab8dc98fad async></script></body></html>