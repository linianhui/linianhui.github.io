<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=google-site-verification content="X6gTMGCy1-_vb5i3aja3ZZyzPY3raiKRJp4VIhOAX24"><meta name=msvalidate.01 content="CDE7502649B75529BD0FCFE89B056E38"><title>[Java] Thread - Timetombs</title>
<link rel=icon type=image/svg href=/favicon.svg><link rel=stylesheet href=https://s4.zstatic.net/ajax/libs/normalize/8.0.1/normalize.min.css crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://s4.zstatic.net/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css crossorigin=anonymous referrerpolicy=no-referrer><link href='/asset/blog.css?time=2025-10-26T19%3a03%3a29Z%2b08%3a00' rel=stylesheet type=text/css><script src=https://s4.zstatic.net/npm/currency.js@2.0.4/dist/currency.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://s4.zstatic.net/ajax/libs/moment.js/2.30.1/moment.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src='/asset/blog.js?time=2025-10-26T19%3a03%3a29Z%2b08%3a00' type=application/javascript></script><script type=text/javascript>blog.isMobile()&&document.write('<link href="/asset/blog.mobile.css?time=2025-10-26T19%3A03%3A29Z%2B08%3A00" rel="stylesheet">')</script></head><body><div id=horizontal-progress class=horizontal-progress></div><aside id=toc class=toc><section class=toc-header><a class=toc-page-title href=/java/ target=_blank>[Java]</a></section><section class=toc-page><a class=toc-page-title href=/java/install/ target=_blank>[Java] Install</a></section><section class=toc-page><a class=toc-page-title href=/java/jvm/ target=_blank>[Java] JVM(Java Virtual Machine)</a></section><section class=toc-page><a class=toc-page-title href=/java/tool/ target=_blank>[Java] Tool</a></section><section class=toc-page><a class=toc-page-title href=/java/unsafe/ target=_blank>[Java] Unsafe类</a></section><section class=toc-page><a class=toc-page-title href=/java/jmm/ target=_blank>[Java] JMM(Java Memory Model)</a></section><section class=toc-page><a class=toc-page-title href=/java/gc/ target=_blank>[Java] GC(Garbage Collection)</a></section><section class="toc-page selected"><span class=toc-page-title>[Java] Thread</span><nav id=TableOfContents><ul><li><a href=#1-os内核态进程>1 OS内核态进程</a></li><li><a href=#2-os内核态线程>2 OS内核态线程</a></li><li><a href=#3-应用用户态协程>3 应用用户态协程</a></li><li><a href=#4-java的线程>4 JAVA的线程</a><ul><li><a href=#41-创建线程>4.1 创建线程</a></li><li><a href=#42-线程的状态>4.2 线程的状态</a></li><li><a href=#43-运行线程>4.3 运行线程</a><ul><li><a href=#431-无返回值runnable接口>4.3.1 无返回值(Runnable接口)</a></li><li><a href=#432-有返回值callable-future和futuretask>4.3.2 有返回值(Callable Future和FutureTask)</a></li></ul></li><li><a href=#44-thread的常用方法>4.4 Thread的常用方法</a></li><li><a href=#45-线程池>4.5 线程池</a><ul><li><a href=#451-blockingqueue>4.5.1 BlockingQueue</a><ul><li><a href=#4511-arrayblockingqueue>4.5.1.1 ArrayBlockingQueue</a></li><li><a href=#4512-linkedblockingqueue>4.5.1.2 LinkedBlockingQueue</a></li><li><a href=#4513-delayqueue>4.5.1.3 DelayQueue</a></li><li><a href=#4514-priorityblockingqueue>4.5.1.4 PriorityBlockingQueue</a></li><li><a href=#4515-synchronousqueue>4.5.1.5 SynchronousQueue</a></li></ul></li><li><a href=#452-rejectedexecutionhandler>4.5.2 RejectedExecutionHandler</a></li></ul></li></ul></li><li><a href=#参考资料>参考资料</a></li></ul></nav></section><section class=toc-page><a class=toc-page-title href=/java/cas/ target=_blank>[Java] CAS(Compare And Swap)</a></section><section class=toc-page><a class=toc-page-title href=/java/synchronized/ target=_blank>[Java] synchronized</a></section><script type=text/javascript>blog.isPC()&&blog.toggleToc()</script></aside><main class=main><header class=header><hgroup class=header-hgroup><h1 class=header-hgroup-title><a href=/>Timetombs</a></h1><h2 class=header-hgroup-subtitle>泛义的工具是文明的基础，而确指的工具却是愚人的器物</h2></hgroup><nav class=header-nav><a class=header-nav-item href=/topic/ title=专题 target=_self><i class="fa fa-folder"></i>专题</a>
<a class=header-nav-item href=/tag/ title=标签 target=_self><i class="fa fa-tags"></i>标签</a>
<a class=header-nav-item href=/archive/ title=归档 target=_self><i class="fa fa-archive"></i>归档</a>
<a class=header-nav-item href=https://linianhui.cnblogs.com title=博客园 target=_black><img src=/asset/cnblogs.favicon.svg>博客园</a>
<a class=header-nav-item href=https://github.com/linianhui/blog title=GitHub target=_black><i class="fa fa-github"></i>GitHub</a></nav><div class=header-stats><div class=stats><span>共
<i>66<sub>h</sub>
</i>/
<i>118<sub>a</sub>
</i>篇</span><div class=stats-date>，更新于 2025-10-26T19:03:29Z+08:00 by &nbsp;
<a class=git-commit href=https://github.com/linianhui/blog/commit/2fac07e818d6d4ad6b78781efea82c28769c8c02 target=_blank><i class="fa fa-code-fork"></i>2fac07e</a></div></div><form class=search method=GET target=_blank action=https://www.bing.com/search><input name=q class=search-input type=search placeholder=search... results=5 onkeypress="search_param.value=search_param_site.value+this.value">
<input id=search_param_site type=hidden value="site:linianhui.github.io ">
<input name=q id=search_param type=hidden></form></div></header><main class=content><article class=article><h1 class=article-title>[Java] Thread</h1><div class=article-copyright><span>版权声明 - </span><a href=/copyright/cc target=_blank>CC BY-NC-SA 4.0</a></div><section class=article-meta><section class=article-date>2020-11-07 19:32，约3139字，阅读约7分钟</section><section class=article-topics><a class=article-topic href=/java/ title=[Java] target=_blank><i class="fa fa-folder"></i>[Java]</a></section><section class=article-tags><a class=article-tag href=/tag/java target=_blank><i class="fa fa-tag"></i>Java</a>
<a class=article-tag href=/tag/thread target=_blank><i class="fa fa-tag"></i>Thread</a></section><section class=article-git><a class=article-git-commit href=https://github.com/linianhui/blog/commit/03e0cc08866458647d96951c1817c624518149d6 target=_blank><i class="fa fa-code-fork"></i>03e0cc0</a>
<span class=article-git-commit-subject>fix add displayed_on_home</span>
<span class=article-git-commit-time>2022-11-20 14:49</span>
<a class=article-git-source href=https://github.com/linianhui/blog/blob/main/src/java/thread/index.md target=_blank><i class="fa fa-github"></i>源码</a></section></section><section class=article-content><h1 id=1-os内核态进程><i id=locator-1-os内核态进程 class=header-locator></i>
<a href=#1-os%e5%86%85%e6%a0%b8%e6%80%81%e8%bf%9b%e7%a8%8b class=article-h-a>1 OS内核态进程</a></h1><p><strong>进程</strong>是OS进行资源分配和调度的最小单元，进程之间互相隔离，这样使得OS可以<strong>并行</strong>运行多个应用程序。<code>OS:进程=1:N</code></p><p>遗留问题：这时OS可以并行多个应用程序了，但是应用程序内部则只能串行的运行。</p><h1 id=2-os内核态线程><i id=locator-2-os内核态线程 class=header-locator></i>
<a href=#2-os%e5%86%85%e6%a0%b8%e6%80%81%e7%ba%bf%e7%a8%8b class=article-h-a>2 OS内核态线程</a></h1><p>为了解决进程遗留的问题，OS就创造了<strong>线程</strong>，使得一个应用程序内部也可以<strong>并行</strong>，<code>进程:线程=1:N</code>。Linux在默认情况下，创建一个线程需要分配8MB的栈内存空间。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:green># 查看默认的栈内存大小</span>
</span></span><span style=display:flex><span>ulimit -s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green># 输出，8192KB=8MB</span>
</span></span><span style=display:flex><span>8192
</span></span></code></pre></div><p>以及从用户态切换到内核态的切换、16个寄存器、PC、SP...等寄存器的刷新等。</p><p>遗留问题：进程和线程的管理调度均有OS负责，这部分操作时在OS的内核态的。所以分配、销毁以及暂停恢复线程就需要用户态和内核态的切换，这部分交互会消耗不少资源，同时线程创建后默认要分配一定的内存空间，这就使得应用程序能创建的线程数量上限受制于OS的内存大小，以及线程过多时，OS在调度上所消耗的资源比重大幅上升。</p><blockquote><p>JAVA目前支持的线程是1:1映射到OS的线程的，早期JAVA在用户态实现过自己的线程，但是调度管理过于复杂，后来又回归了1:1映射OS的原生线程了。</p></blockquote><h1 id=3-应用用户态协程><i id=locator-3-应用用户态协程 class=header-locator></i>
<a href=#3-%e5%ba%94%e7%94%a8%e7%94%a8%e6%88%b7%e6%80%81%e5%8d%8f%e7%a8%8b class=article-h-a>3 应用用户态协程</a></h1><p>为了解决线程遗留的问题。故而现在很多编程语言(<a href target=_blank rel="noopener norefferrer">Go</a>、<a href=https://wiki.openjdk.java.net/display/loom/Main target=_blank rel="noopener norefferrer">Java Loom Projec</a>)在语言层面实现了协程，由语言的运行时在用户态负责调度管理协程，<code>线程:协程=1:N</code>。由于协程的管理调度均在用户态进行管理，故而可以大幅的降低内核态和用户态的切换带来的资源消耗。</p><p>创建协程的资源消耗比线程小的多，Go中一个协程消耗<code>2kB</code>的内存，以及3个寄存器<code>PC / SP / DX</code>足以。</p><h1 id=4-java的线程><i id=locator-4-java的线程 class=header-locator></i>
<a href=#4-java%e7%9a%84%e7%ba%bf%e7%a8%8b class=article-h-a>4 JAVA的线程</a></h1><p>上面说到JAVA的线程是1:1映射到OS的线程的，只是Java的线程默认栈大小为<code>1MB</code>。在Java中用<a href=https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html target=_blank rel="noopener norefferrer">java.lang.Thread</a>代表一个线程。</p><h2 id=41-创建线程><i id=locator-41-创建线程 class=header-locator></i>
<a href=#41-%e5%88%9b%e5%bb%ba%e7%ba%bf%e7%a8%8b class=article-h-a>4.1 创建线程</a></h2><p>Thread的几个构造函数均是调用内部的init方法来完成线程对象的创建的。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>private</span> <span style=color:#2b91af>void</span> init(
</span></span><span style=display:flex><span>    ThreadGroup g, 
</span></span><span style=display:flex><span>    Runnable target, 
</span></span><span style=display:flex><span>    String name,
</span></span><span style=display:flex><span>    <span style=color:#2b91af>long</span> stackSize, 
</span></span><span style=display:flex><span>    AccessControlContext acc,
</span></span><span style=display:flex><span>    <span style=color:#2b91af>boolean</span> inheritThreadLocals
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><ol><li><code>g</code> : 线程组</li><li><code>target</code> : 待运行的任务</li><li><code>name</code> : 线程名，有意义的名字便于线上环境分析问题。</li><li><code>stackSize</code> : 栈大小，默认是0代表不设置，采用1MB默认值。</li><li><code>acc</code> : 访问控制上下文。</li><li><code>inheritThreadLocals</code> : 是否继承当前线程的局部变量信息(ThreadLocal)。</li></ol><h2 id=42-线程的状态><i id=locator-42-线程的状态 class=header-locator></i>
<a href=#42-%e7%ba%bf%e7%a8%8b%e7%9a%84%e7%8a%b6%e6%80%81 class=article-h-a>4.2 线程的状态</a></h2><p>具有6中状态<a href=https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.State.html target=_blank rel="noopener norefferrer">java.lang.Thread.State</a>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>enum</span> State {
</span></span><span style=display:flex><span>    <span style=color:green>/**
</span></span></span><span style=display:flex><span><span style=color:green>      * Thread thread = new Thread(()-&gt;{});
</span></span></span><span style=display:flex><span><span style=color:green>      * 仅仅new一个对象时，处于NEW状态。 
</span></span></span><span style=display:flex><span><span style=color:green>      */</span>
</span></span><span style=display:flex><span>    NEW,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>/**
</span></span></span><span style=display:flex><span><span style=color:green>      * thread.start();
</span></span></span><span style=display:flex><span><span style=color:green>      * 调用start后处于RUNNABLE状态。或者
</span></span></span><span style=display:flex><span><span style=color:green>      * {@link Object#notify()}
</span></span></span><span style=display:flex><span><span style=color:green>      * {@link Object#notifyAll()}
</span></span></span><span style=display:flex><span><span style=color:green>      * {@link LookSupport#unpack(Object thread)}
</span></span></span><span style=display:flex><span><span style=color:green>      * {@link Unsafe#unpack(Object thread)}
</span></span></span><span style=display:flex><span><span style=color:green>      * 获取进入了synchronized代码块时。
</span></span></span><span style=display:flex><span><span style=color:green>      */</span>
</span></span><span style=display:flex><span>    RUNNABLE,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>/**
</span></span></span><span style=display:flex><span><span style=color:green>      * 等待进入synchronized代码块时。
</span></span></span><span style=display:flex><span><span style=color:green>      */</span>
</span></span><span style=display:flex><span>    BLOCKED,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>/**
</span></span></span><span style=display:flex><span><span style=color:green>      * 一下方法会使得线程处于等待状态，并且交出CPU。
</span></span></span><span style=display:flex><span><span style=color:green>      * {@link Object#wait()}
</span></span></span><span style=display:flex><span><span style=color:green>      * {@link Thread#join()}
</span></span></span><span style=display:flex><span><span style=color:green>      * {@link LockSupport#park()}
</span></span></span><span style=display:flex><span><span style=color:green>      * {@link Unsafe#park(false,0L)}
</span></span></span><span style=display:flex><span><span style=color:green>      * 直到调用一下方法唤醒:
</span></span></span><span style=display:flex><span><span style=color:green>      * {@link Object#notify()}
</span></span></span><span style=display:flex><span><span style=color:green>      * {@link Object#notifyAll()}
</span></span></span><span style=display:flex><span><span style=color:green>      * {@link LookSupport#unpack(Object thread)}
</span></span></span><span style=display:flex><span><span style=color:green>      * {@link Unsafe#unpack(Object thread)}
</span></span></span><span style=display:flex><span><span style=color:green>      */</span>
</span></span><span style=display:flex><span>    WAITING,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>/**
</span></span></span><span style=display:flex><span><span style=color:green>      * 一下方法会使得线程处于等待指定的时间。
</span></span></span><span style=display:flex><span><span style=color:green>      * {@link Object#wait(long timeout)}
</span></span></span><span style=display:flex><span><span style=color:green>      * {@link Object#wait(long timeout, int nanos)}
</span></span></span><span style=display:flex><span><span style=color:green>      * {@link Thread#join(long millis)}
</span></span></span><span style=display:flex><span><span style=color:green>      * {@link Thread#join(long millis, int nanos)}
</span></span></span><span style=display:flex><span><span style=color:green>      * {@link LockSupport#parkNanos(long nanos)}
</span></span></span><span style=display:flex><span><span style=color:green>      * {@link LockSupport#parkUntil(long deadline)}
</span></span></span><span style=display:flex><span><span style=color:green>      * {@link Thread#sleep(long millis)} 仅交出CPU，不释放锁。
</span></span></span><span style=display:flex><span><span style=color:green>      * {@link Thread#sleep(long millis, int nanos)} 仅交出CPU，不释放锁。
</span></span></span><span style=display:flex><span><span style=color:green>      */</span>
</span></span><span style=display:flex><span>    TIMED_WAITING,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>/**
</span></span></span><span style=display:flex><span><span style=color:green>      * 线程运行完毕
</span></span></span><span style=display:flex><span><span style=color:green>      */</span>
</span></span><span style=display:flex><span>    TERMINATED;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>状态迁移图:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>stateDiagram-v2
</span></span><span style=display:flex><span>    NEW --&gt; RUNNABLE : Thread#start()
</span></span><span style=display:flex><span>    RUNNABLE --&gt; WAITTING : Object#wait()&lt;br/&gt;Thread#join()&lt;br/&gt;LockSupport#park()
</span></span><span style=display:flex><span>    WAITTING --&gt; RUNNABLE : Object#notify()&lt;br/&gt;Object#notifyAll()&lt;br/&gt;LockSupport#unpack(Object thread)
</span></span><span style=display:flex><span>    RUNNABLE --&gt; TIMED_WAITTING : Object#wait(long timeout)&lt;br/&gt;Thread#join(long millis)&lt;br/&gt;Thread#sleep(long millis)&lt;br/&gt;LockSupport#parkNanos(long nanos)&lt;br/&gt;LockSupport#parkUntil(long deadline)
</span></span><span style=display:flex><span>    TIMED_WAITTING --&gt; RUNNABLE : timeout&lt;br/&gt;Object#notify()&lt;br/&gt;Object#notifyAll()&lt;br/&gt;LockSupport#unpack(Object thread)
</span></span><span style=display:flex><span>    RUNNABLE --&gt; BLACKED : 等待进入monitor(synchronized)
</span></span><span style=display:flex><span>    BLACKED --&gt; RUNNABLE : 进入monitor(synchronized)
</span></span><span style=display:flex><span>    RUNNABLE --&gt; TERMINATED : 运行结束&lt;br/&gt;异常
</span></span><span style=display:flex><span>    WAITTING --&gt; TERMINATED : 异常
</span></span><span style=display:flex><span>    TIMED_WAITTING --&gt; TERMINATED : 异常
</span></span></code></pre></div><h2 id=43-运行线程><i id=locator-43-运行线程 class=header-locator></i>
<a href=#43-%e8%bf%90%e8%a1%8c%e7%ba%bf%e7%a8%8b class=article-h-a>4.3 运行线程</a></h2><p>可以通过继承Thread或者传递一个Runnable接口的对象来运行一个线程。通常采用传递Runnable接口的方式，这样可以使得任务和线程分离。<br>然后调用<code>thread.start()</code>方法来启动运行一个线程，注意次方法只能调用一次，第二次就会抛出一个<code>IllegalThreadStateException</code>的异常(第一次start时会改变线程内部的状态，从而进入RUNNABLE状态，不能回退，start方法内部会检查这个状态)。也不能调用<code>thread.run()</code>方法，这样只会直接调用Runnable接口的run方法，相当于在当前线程执行任务。</p><h3 id=431-无返回值runnable接口><i id=locator-431-无返回值runnable接口 class=header-locator></i>
<a href=#431-%e6%97%a0%e8%bf%94%e5%9b%9e%e5%80%bcrunnable%e6%8e%a5%e5%8f%a3 class=article-h-a>4.3.1 无返回值(Runnable接口)</a></h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>@FunctionalInterface
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>interface</span> <span style=color:#2b91af>Runnable</span> {
</span></span><span style=display:flex><span>    <span style=color:#00f>public</span> <span style=color:#00f>abstract</span> <span style=color:#2b91af>void</span> run();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=432-有返回值callable-future和futuretask><i id=locator-432-有返回值callable-future和futuretask class=header-locator></i>
<a href=#432-%e6%9c%89%e8%bf%94%e5%9b%9e%e5%80%bccallable-future%e5%92%8cfuturetask class=article-h-a>4.3.2 有返回值(Callable Future和FutureTask)</a></h3><p>不同于Runnable，Callable会得到一个返回值。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>@FunctionalInterface
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>interface</span> <span style=color:#2b91af>Callable</span>&lt;V&gt; {
</span></span><span style=display:flex><span>    V call() <span style=color:#00f>throws</span> Exception;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>通过ExecutorService来提交一个Callable。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>interface</span> <span style=color:#2b91af>ExecutorService</span> <span style=color:#00f>extends</span> Executor {
</span></span><span style=display:flex><span>    <span style=color:green>// 其他方法</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>// 提交一个有返回值的任务，通过Future获得返回值。</span>
</span></span><span style=display:flex><span>    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Future接口的get方法可以获得Callable的返回值，也可以通过它取消任务的执行。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>interface</span> <span style=color:#2b91af>Future</span>&lt;V&gt; {
</span></span><span style=display:flex><span>    <span style=color:#2b91af>boolean</span> cancel(<span style=color:#2b91af>boolean</span> mayInterruptIfRunning);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>boolean</span> isCancelled();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>boolean</span> isDone();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    V get() <span style=color:#00f>throws</span> InterruptedException, ExecutionException;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    V get(<span style=color:#2b91af>long</span> timeout, TimeUnit unit) <span style=color:#00f>throws</span> InterruptedException, ExecutionException, TimeoutException;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=44-thread的常用方法><i id=locator-44-thread的常用方法 class=header-locator></i>
<a href=#44-thread%e7%9a%84%e5%b8%b8%e7%94%a8%e6%96%b9%e6%b3%95 class=article-h-a>4.4 Thread的常用方法</a></h2><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green>// 开始执行</span>
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>synchronized</span> <span style=color:#2b91af>void</span> start();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// 出让CPU，让OS重新调度，当然也有可能又调度到了当前线程。</span>
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>static</span> <span style=color:#00f>native</span> <span style=color:#2b91af>void</span> yield();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// 使当前线程睡眠指定的时间，不释放锁。</span>
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>static</span> <span style=color:#00f>native</span> <span style=color:#2b91af>void</span> sleep(<span style=color:#2b91af>long</span> millis) <span style=color:#00f>throws</span> InterruptedException;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// 让当前线程处于等待状态，等待调用join的线程执行完毕后再继续，内部是通过Object.wait实现的</span>
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>final</span> <span style=color:#2b91af>void</span> join() <span style=color:#00f>throws</span> InterruptedException {
</span></span><span style=display:flex><span>    join(0);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>final</span> <span style=color:#00f>synchronized</span> <span style=color:#2b91af>void</span> join(<span style=color:#2b91af>long</span> millis)
</span></span><span style=display:flex><span><span style=color:#00f>throws</span> InterruptedException {
</span></span><span style=display:flex><span>    <span style=color:#2b91af>long</span> base = System.currentTimeMillis();
</span></span><span style=display:flex><span>    <span style=color:#2b91af>long</span> now = 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>if</span> (millis &lt; 0) {
</span></span><span style=display:flex><span>        <span style=color:#00f>throw</span> <span style=color:#00f>new</span> IllegalArgumentException(<span style=color:#a31515>&#34;timeout value is negative&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00f>if</span> (millis == 0) {
</span></span><span style=display:flex><span>        <span style=color:#00f>while</span> (isAlive()) {
</span></span><span style=display:flex><span>            wait(0);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#00f>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#00f>while</span> (isAlive()) {
</span></span><span style=display:flex><span>            <span style=color:#2b91af>long</span> delay = millis - now;
</span></span><span style=display:flex><span>            <span style=color:#00f>if</span> (delay &lt;= 0) {
</span></span><span style=display:flex><span>                <span style=color:#00f>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            wait(delay);
</span></span><span style=display:flex><span>            now = System.currentTimeMillis() - base;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// 获取当前线程</span>
</span></span><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>static</span> <span style=color:#00f>native</span> Thread currentThread();
</span></span></code></pre></div><h2 id=45-线程池><i id=locator-45-线程池 class=header-locator></i>
<a href=#45-%e7%ba%bf%e7%a8%8b%e6%b1%a0 class=article-h-a>4.5 线程池</a></h2><p>通常来说我们不会直接new一个Thread来使用，而是通过线程池来管理维护一个合适的线程数量，这样可以减少线程创建以及维护的开销。在Java中的线程池的接口是Executor，ThreadPoolExecutor是这个接口的实现类。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>public</span> ThreadPoolExecutor(
</span></span><span style=display:flex><span>    <span style=color:#2b91af>int</span> corePoolSize,                  <span style=color:green>// 核心线程数量</span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>int</span> maximumPoolSize,               <span style=color:green>// 最大线程数量</span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>long</span> keepAliveTime,                <span style=color:green>// 线程存活时间，当没有任务时，多出核心线程数量的线程可以存活多久。</span>
</span></span><span style=display:flex><span>    TimeUnit unit,                     <span style=color:green>// 存活时间的单位</span>
</span></span><span style=display:flex><span>    BlockingQueue&lt;Runnable&gt; workQueue, <span style=color:green>// 任务的阻塞队列</span>
</span></span><span style=display:flex><span>    ThreadFactory threadFactory,       <span style=color:green>// 创建线程的工厂</span>
</span></span><span style=display:flex><span>    RejectedExecutionHandler handler   <span style=color:green>// 拒绝策略</span>
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><h3 id=451-blockingqueue><i id=locator-451-blockingqueue class=header-locator></i>
<a href=#451-blockingqueue class=article-h-a>4.5.1 BlockingQueue</a></h3><p>保存待执行的Runnable对象的队列（线程安全）。常用的方法有如下几个：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>interface</span> <span style=color:#2b91af>BlockingQueue</span>&lt;E&gt; <span style=color:#00f>extends</span> Queue&lt;E&gt;{
</span></span><span style=display:flex><span>  <span style=color:green>// 插入元素 </span>
</span></span><span style=display:flex><span>  <span style=color:green>// 队列已满时 : 抛出异常IllegalStateException(“Queue full”)</span>
</span></span><span style=display:flex><span>  <span style=color:#2b91af>boolean</span> add(E e);
</span></span><span style=display:flex><span>  <span style=color:green>// 队列已满时 : 返回false</span>
</span></span><span style=display:flex><span>  <span style=color:#2b91af>boolean</span> offer(E e);
</span></span><span style=display:flex><span>  <span style=color:green>// 队列已满时 : 一直阻塞到可以插入</span>
</span></span><span style=display:flex><span>  <span style=color:#2b91af>void</span> put(E e) <span style=color:#00f>throws</span> InterruptedException;
</span></span><span style=display:flex><span>  <span style=color:green>// 队列已满时 : 阻塞指定的时间</span>
</span></span><span style=display:flex><span>  <span style=color:#2b91af>boolean</span> offer(E e, <span style=color:#2b91af>long</span> timeout, TimeUnit unit) <span style=color:#00f>throws</span> InterruptedException;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>  <span style=color:green>// 移除元素</span>
</span></span><span style=display:flex><span>  <span style=color:green>// 队列为空 : 抛出异常</span>
</span></span><span style=display:flex><span>  E remove();
</span></span><span style=display:flex><span>  <span style=color:green>// 队列为空 : 返回null</span>
</span></span><span style=display:flex><span>  E poll();
</span></span><span style=display:flex><span>  <span style=color:green>// 队列为空 : 一直阻塞</span>
</span></span><span style=display:flex><span>  E take() <span style=color:#00f>throws</span> InterruptedException;
</span></span><span style=display:flex><span>  <span style=color:green>// 队列为空 : 阻塞指定的时间</span>
</span></span><span style=display:flex><span>  E poll(<span style=color:#2b91af>long</span> timeout, TimeUnit unit)<span style=color:#00f>throws</span> InterruptedException;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:green>// 检查元素</span>
</span></span><span style=display:flex><span>  <span style=color:green>// 抛异常</span>
</span></span><span style=display:flex><span>  E element();
</span></span><span style=display:flex><span>  <span style=color:green>// 返回null</span>
</span></span><span style=display:flex><span>  E peek();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>常用的实现类有：</p><h4 id=4511-arrayblockingqueue><i id=locator-4511-arrayblockingqueue class=header-locator></i>
<a href=#4511-arrayblockingqueue class=article-h-a>4.5.1.1 ArrayBlockingQueue</a></h4><p>数组实现的有界的固定大小的队列，默认时非空公平锁实现的。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>class</span> <span style=color:#2b91af>ArrayBlockingQueue</span>&lt;E&gt; <span style=color:#00f>extends</span> AbstractQueue&lt;E&gt;
</span></span><span style=display:flex><span>        <span style=color:#00f>implements</span> BlockingQueue&lt;E&gt;, java.io.Serializable{
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#00f>public</span> ArrayBlockingQueue(<span style=color:#2b91af>int</span> capacity) {
</span></span><span style=display:flex><span>        <span style=color:#00f>this</span>(capacity, <span style=color:#00f>false</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#00f>public</span> ArrayBlockingQueue(<span style=color:#2b91af>int</span> capacity, <span style=color:#2b91af>boolean</span> fair) {
</span></span><span style=display:flex><span>      <span style=color:#00f>if</span> (capacity &lt;= 0)
</span></span><span style=display:flex><span>          <span style=color:#00f>throw</span> <span style=color:#00f>new</span> IllegalArgumentException();
</span></span><span style=display:flex><span>      <span style=color:#00f>this</span>.items = <span style=color:#00f>new</span> Object[capacity];
</span></span><span style=display:flex><span>      lock = <span style=color:#00f>new</span> ReentrantLock(fair);
</span></span><span style=display:flex><span>      notEmpty = lock.newCondition();
</span></span><span style=display:flex><span>      notFull =  lock.newCondition();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=4512-linkedblockingqueue><i id=locator-4512-linkedblockingqueue class=header-locator></i>
<a href=#4512-linkedblockingqueue class=article-h-a>4.5.1.2 LinkedBlockingQueue</a></h4><p>链表实现的有界的队列，默认队列的大小是Integer.MAX_VALUE。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>class</span> <span style=color:#2b91af>LinkedBlockingDeque</span>&lt;E&gt; <span style=color:#00f>extends</span> AbstractQueue&lt;E&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>implements</span> BlockingDeque&lt;E&gt;, java.io.Serializable {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#00f>public</span> LinkedBlockingDeque() {
</span></span><span style=display:flex><span>      <span style=color:#00f>this</span>(Integer.MAX_VALUE);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#00f>public</span> LinkedBlockingDeque(<span style=color:#2b91af>int</span> capacity) {
</span></span><span style=display:flex><span>      <span style=color:#00f>if</span> (capacity &lt;= 0) <span style=color:#00f>throw</span> <span style=color:#00f>new</span> IllegalArgumentException();
</span></span><span style=display:flex><span>      <span style=color:#00f>this</span>.capacity = capacity;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=4513-delayqueue><i id=locator-4513-delayqueue class=header-locator></i>
<a href=#4513-delayqueue class=article-h-a>4.5.1.3 DelayQueue</a></h4><p>内部是用PriorityQueued实现的无界队列，没有队列大小限制，插入元素不会阻塞，但是获取元素会被延迟。队列中的元素必须实现<code>Delayed</code>接口。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>interface</span> <span style=color:#2b91af>Delayed</span> <span style=color:#00f>extends</span> Comparable&lt;Delayed&gt; {
</span></span><span style=display:flex><span>    <span style=color:#2b91af>long</span> getDelay(TimeUnit unit);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>class</span> <span style=color:#2b91af>DelayQueue</span>&lt;E <span style=color:#00f>extends</span> Delayed&gt; <span style=color:#00f>extends</span> AbstractQueue&lt;E&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>implements</span> BlockingQueue&lt;E&gt; {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>private</span> <span style=color:#00f>final</span> <span style=color:#00f>transient</span> ReentrantLock lock = <span style=color:#00f>new</span> ReentrantLock();
</span></span><span style=display:flex><span><span style=color:#00f>private</span> <span style=color:#00f>final</span> PriorityQueue&lt;E&gt; q = <span style=color:#00f>new</span> PriorityQueue&lt;E&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=4514-priorityblockingqueue><i id=locator-4514-priorityblockingqueue class=header-locator></i>
<a href=#4514-priorityblockingqueue class=article-h-a>4.5.1.4 PriorityBlockingQueue</a></h4><p>通过Comparator实现的具有优先级的无界队列。默认非公平锁。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>class</span> <span style=color:#2b91af>PriorityBlockingQueue</span>&lt;E&gt; <span style=color:#00f>extends</span> AbstractQueue&lt;E&gt;
</span></span><span style=display:flex><span>    <span style=color:#00f>implements</span> BlockingQueue&lt;E&gt;, java.io.Serializable {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#00f>public</span> PriorityBlockingQueue(<span style=color:#2b91af>int</span> initialCapacity) {
</span></span><span style=display:flex><span>      <span style=color:#00f>this</span>(initialCapacity, <span style=color:#00f>null</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#00f>public</span> PriorityBlockingQueue(<span style=color:#2b91af>int</span> initialCapacity,
</span></span><span style=display:flex><span>                                Comparator&lt;? <span style=color:#00f>super</span> E&gt; comparator) {
</span></span><span style=display:flex><span>      <span style=color:#00f>if</span> (initialCapacity &lt; 1)
</span></span><span style=display:flex><span>          <span style=color:#00f>throw</span> <span style=color:#00f>new</span> IllegalArgumentException();
</span></span><span style=display:flex><span>      <span style=color:#00f>this</span>.lock = <span style=color:#00f>new</span> ReentrantLock();
</span></span><span style=display:flex><span>      <span style=color:#00f>this</span>.notEmpty = lock.newCondition();
</span></span><span style=display:flex><span>      <span style=color:#00f>this</span>.comparator = comparator;
</span></span><span style=display:flex><span>      <span style=color:#00f>this</span>.queue = <span style=color:#00f>new</span> Object[initialCapacity];
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=4515-synchronousqueue><i id=locator-4515-synchronousqueue class=header-locator></i>
<a href=#4515-synchronousqueue class=article-h-a>4.5.1.5 SynchronousQueue</a></h4><p>容量为0的队列。每个take必须等待一个put。</p><h3 id=452-rejectedexecutionhandler><i id=locator-452-rejectedexecutionhandler class=header-locator></i>
<a href=#452-rejectedexecutionhandler class=article-h-a>4.5.2 RejectedExecutionHandler</a></h3><p>当线程数量大于最大线程数量时，会触发拒绝策略。jdk默认提供的四种策略如下：</p><ol><li>ThreadPoolExecutor.AbortPolicy ：默认拒绝处理策略，丢弃任务并抛出RejectedExecutionException异常。</li><li>ThreadPoolExecutor.DiscardPolicy ：丢弃新来的任务，但是不抛出异常。</li><li>ThreadPoolExecutor.DiscardOldestPolicy ：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。</li><li>ThreadPoolExecutor.CallerRunsPolicy ：由调用线程处理该任务。</li></ol><h1 id=参考资料><i id=locator-参考资料 class=header-locator></i>
<a href=#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99 class=article-h-a>参考资料</a></h1><ol><li>Go Memory Model : <a href=https://golang.org/ref/mem target=_blank rel="noopener norefferrer">https://golang.org/ref/mem</a></li><li>深度剖析Go协程 : <a href=https://studygolang.com/articles/17944 target=_blank rel="noopener norefferrer">https://studygolang.com/articles/17944</a></li><li>Java Loom Project : <a href=https://wiki.openjdk.java.net/display/loom/Main target=_blank rel="noopener norefferrer">https://wiki.openjdk.java.net/display/loom/Main</a></li><li>深入浅出Java多线程-线程 : <a href=http://concurrent.redspider.group/article/01/2.html target=_blank rel="noopener norefferrer">http://concurrent.redspider.group/article/01/2.html</a></li><li>java.lang.Thread : <a href=https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html target=_blank rel="noopener norefferrer">https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html</a></li><li>java.lang.Thread.State : <a href=https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.State.html target=_blank rel="noopener norefferrer">https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.State.html</a></li></ol></section><section class=article-meta><section class=article-date>2020-11-07 19:32，约3139字，阅读约7分钟</section><section class=article-topics><a class=article-topic href=/java/ title=[Java] target=_blank><i class="fa fa-folder"></i>[Java]</a></section><section class=article-tags><a class=article-tag href=/tag/java target=_blank><i class="fa fa-tag"></i>Java</a>
<a class=article-tag href=/tag/thread target=_blank><i class="fa fa-tag"></i>Thread</a></section><section class=article-git><a class=article-git-commit href=https://github.com/linianhui/blog/commit/03e0cc08866458647d96951c1817c624518149d6 target=_blank><i class="fa fa-code-fork"></i>03e0cc0</a>
<span class=article-git-commit-subject>fix add displayed_on_home</span>
<span class=article-git-commit-time>2022-11-20 14:49</span>
<a class=article-git-source href=https://github.com/linianhui/blog/blob/main/src/java/thread/index.md target=_blank><i class="fa fa-github"></i>源码</a></section></section><section class=article-page><div class=article-page-prev><span>上一篇 : </span><a href=/java/gc/ target=_blank>[Java] GC(Garbage Collection)</a></div><div class=article-page-next><span>下一篇 : </span><a href=/java/cas/ target=_blank>[Java] CAS(Compare And Swap)</a></div></section></article><section id=article-comment class=article-comment><script src=https://utteranc.es/client.js repo=linianhui/blog issue-term=pathname label=blog-comment theme=github-light crossorigin=anonymous async></script></section></main><footer class=footer><section>Copyright © 2025 by <a href=https://github.com/linianhui/blog target=_blank>Timetombs</a></section><section><a class=article-git-commit href=https://github.com/linianhui/blog/commit/2fac07e818d6d4ad6b78781efea82c28769c8c02 target=_blank><i class="fa fa-code-fork"></i>2fac07e</a>
Powered by
<a href=https://github.com/actions target=_blank>GitHub Actions</a>
,
<a href=https://github.com/gohugoio/hugo target=_blank>Hugo</a>
and
<a href=https://github.com/utterance/utterances target=_blank>utterances</a>
Hosted on <a href=https://pages.github.com/ target=_blank>GitHub Pages</a><section></footer></main><aside class=toolbar><a class="fa fa-list" href=javascript:blog.toggleToc(); title=目录></a><a class="fa fa-comments" href=#article-comment title=评论></a><a class="fa fa-arrow-up" href=javascript:scroll(0,0); title=返回顶部></a></aside><script type=text/javascript>var _hmt=_hmt||[];blog.addOnScorllEvent()</script><script src=https://hm.baidu.com/hm.js?b2cc3cea316e1f7a8def1bab8dc98fad async></script></body></html>