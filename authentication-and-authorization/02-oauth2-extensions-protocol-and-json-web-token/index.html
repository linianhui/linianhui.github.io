<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=google-site-verification content="X6gTMGCy1-_vb5i3aja3ZZyzPY3raiKRJp4VIhOAX24"><meta name=msvalidate.01 content="CDE7502649B75529BD0FCFE89B056E38"><title>[认证&授权] 02 OAuth2授权(续) & JWT(JSON Web Token) - Timetombs</title>
<link rel=icon type=image/svg href=/favicon.svg><link rel=stylesheet href=https://s4.zstatic.net/ajax/libs/normalize/8.0.1/normalize.min.css crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://s4.zstatic.net/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css crossorigin=anonymous referrerpolicy=no-referrer><link href='/asset/blog.css?time=2025-10-26T19%3a03%3a29Z%2b08%3a00' rel=stylesheet type=text/css><script src=https://s4.zstatic.net/npm/currency.js@2.0.4/dist/currency.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://s4.zstatic.net/ajax/libs/moment.js/2.30.1/moment.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src='/asset/blog.js?time=2025-10-26T19%3a03%3a29Z%2b08%3a00' type=application/javascript></script><script type=text/javascript>blog.isMobile()&&document.write('<link href="/asset/blog.mobile.css?time=2025-10-26T19%3A03%3A29Z%2B08%3A00" rel="stylesheet">')</script></head><body><div id=horizontal-progress class=horizontal-progress></div><aside id=toc class=toc><section class=toc-header><a class=toc-page-title href=/authentication-and-authorization/ target=_blank>[认证&授权]</a></section><section class=toc-page><a class=toc-page-title href=/authentication-and-authorization/01-oauth2-authorization/ target=_blank>[认证&授权] 01 OAuth2授权</a></section><section class="toc-page selected"><span class=toc-page-title>[认证&授权] 02 OAuth2授权(续) & JWT(JSON Web Token)</span><nav id=TableOfContents><ul><li><a href=#rfc6749-defects>1 RFC6749还有哪些可以完善的？</a><ul><li><a href=#token-revocation>1.1 撤销Token</a></li><li><a href=#token-opaque>1.2 Token对Client的不透明问题</a></li></ul></li><li><a href=#rfc7009-oauth2-token-revocation>2 RFC7009 OAuth2 Token Revocation</a></li><li><a href=#rfc7662-oauth2-token-introspection>3 RFC7662 OAuth2 Token Introspection</a></li><li><a href=#json-web-token>4 JSON Web Token (JWT)</a><ul><li><a href=#json-web-token-header>4.1 Header</a></li><li><a href=#json-web-token-payload>4.2 Payload</a></li><li><a href=#json-web-token-signature>4.3 Signature</a></li><li><a href=#json-web-token-signature>4.4 JWT Claims</a></li><li><a href=#json-web-token-application-scenarios>4.5 JWT 应用场景</a></li></ul></li><li><a href=#oauth2-and-json-web-token>5 OAuth2 & JWT</a></li><li><a href=#summary>6 总结</a></li><li><a href=#reference>7 参考资料</a></li></ul></nav></section><section class=toc-page><a class=toc-page-title href=/authentication-and-authorization/03-user-authentication-with-oauth2/ target=_blank>[认证&授权] 03 使用OAuth2进行用户认证(译)</a></section><section class=toc-page><a class=toc-page-title href=/authentication-and-authorization/04-openid-connect-core/ target=_blank>[认证&授权] 04 OIDC(OpenId Connect)身份认证(核心部分)</a></section><section class=toc-page><a class=toc-page-title href=/authentication-and-authorization/05-openid-connect-extension/ target=_blank>[认证&授权] 05 OIDC(OpenId Connect)身份认证(扩展部分)</a></section><section class=toc-page><a class=toc-page-title href=/authentication-and-authorization/06-permission-based-access-control/ target=_blank>[认证&授权] 06 Permission Based Access Control</a></section><script type=text/javascript>blog.isPC()&&blog.toggleToc()</script></aside><main class=main><header class=header><hgroup class=header-hgroup><h1 class=header-hgroup-title><a href=/>Timetombs</a></h1><h2 class=header-hgroup-subtitle>泛义的工具是文明的基础，而确指的工具却是愚人的器物</h2></hgroup><nav class=header-nav><a class=header-nav-item href=/topic/ title=专题 target=_self><i class="fa fa-folder"></i>专题</a>
<a class=header-nav-item href=/tag/ title=标签 target=_self><i class="fa fa-tags"></i>标签</a>
<a class=header-nav-item href=/archive/ title=归档 target=_self><i class="fa fa-archive"></i>归档</a>
<a class=header-nav-item href=https://linianhui.cnblogs.com title=博客园 target=_black><img src=/asset/cnblogs.favicon.svg>博客园</a>
<a class=header-nav-item href=https://github.com/linianhui/blog title=GitHub target=_black><i class="fa fa-github"></i>GitHub</a></nav><div class=header-stats><div class=stats><span>共
<i>66<sub>h</sub>
</i>/
<i>118<sub>a</sub>
</i>篇</span><div class=stats-date>，更新于 2025-10-26T19:03:29Z+08:00 by &nbsp;
<a class=git-commit href=https://github.com/linianhui/blog/commit/2fac07e818d6d4ad6b78781efea82c28769c8c02 target=_blank><i class="fa fa-code-fork"></i>2fac07e</a></div></div><form class=search method=GET target=_blank action=https://www.bing.com/search><input name=q class=search-input type=search placeholder=search... results=5 onkeypress="search_param.value=search_param_site.value+this.value">
<input id=search_param_site type=hidden value="site:linianhui.github.io ">
<input name=q id=search_param type=hidden></form></div></header><main class=content><article class=article><h1 class=article-title>[认证&授权] 02 OAuth2授权(续) & JWT(JSON Web Token)</h1><div class=article-copyright><span>版权声明 - </span><a href=/copyright/cc target=_blank>CC BY-NC-SA 4.0</a></div><section class=article-meta><section class=article-date>2017-04-03 03:56，约4390字，阅读约9分钟</section><section class=article-topics><a class=article-topic href=/authentication-and-authorization/ title=[认证&授权] target=_blank><i class="fa fa-folder"></i>[认证&授权]</a></section><section class=article-tags><a class=article-tag href=/tag/jwt target=_blank><i class="fa fa-tag"></i>JWT</a>
<a class=article-tag href=/tag/oauth2 target=_blank><i class="fa fa-tag"></i>OAuth2</a></section><section class=article-git><a class=article-git-commit href=https://github.com/linianhui/blog/commit/03e0cc08866458647d96951c1817c624518149d6 target=_blank><i class="fa fa-code-fork"></i>03e0cc0</a>
<span class=article-git-commit-subject>fix add displayed_on_home</span>
<span class=article-git-commit-time>2022-11-20 14:49</span>
<a class=article-git-source href=https://github.com/linianhui/blog/blob/main/src/authentication-and-authorization/02-oauth2-extensions-protocol-and-json-web-token/index.md target=_blank><i class="fa fa-github"></i>源码</a></section></section><section class=article-content><h1 id=rfc6749-defects><i id=locator-rfc6749-defects class=header-locator></i>
<a href=#rfc6749-defects class=article-h-a>1 RFC6749还有哪些可以完善的？</a></h1><h2 id=token-revocation><i id=locator-token-revocation class=header-locator></i>
<a href=#token-revocation class=article-h-a>1.1 撤销Token</a></h2><p>在上篇<a href=../01-oauth2-authorization/ target=_blank rel="noopener norefferrer">[认证&授权] 01 OAuth2授权</a>中介绍到了OAuth2可以帮我们解决第三方Client访问受保护资源的问题，但是只提供了如何获得access_token，并未说明怎么来撤销一个access_token。关于这部分OAuth2单独定义了一个<a href=https://tools.ietf.org/html/rfc7009 target=_blank rel="noopener norefferrer">RFC7009 - OAuth 2.0 Token Revocation</a>来解决撤销Token问题。</p><h2 id=token-opaque><i id=locator-token-opaque class=header-locator></i>
<a href=#token-opaque class=article-h-a>1.2 Token对Client的不透明问题</a></h2><p>OAuth2提供的<code>access_token</code>是一个对Client不透明的字符串，尽管有<code>scope</code>，<code>expires_in</code>和<code>refresh_token</code>来辅助，但也是不完善的且分散的信息。还拿上一篇的小明来举例 : <strong>小明</strong>授权<strong>在线打印并且包邮的网站</strong>访问<strong>自己的QQ空间</strong>的<strong>相册</strong>。这句话其中有4个重要的概念 :</p><ol><li>授权者<strong>小明</strong> : 表示是小明授权，而不是隔壁老王。</li><li>被授权者<strong>在线打印并且包邮的网站</strong> : 表示授权给指定的网站，而不是其他的比如1024.com之类的网站(你懂的。。。)。</li><li>小明<strong>自己的QQ空间</strong>表示让被授权者访问自己的信息，而不是隔壁老王的信息，小明也没这权限来着，不然隔壁王婶夜不答应吧。。。</li><li><strong>相册</strong> : 表示你可以访问我的相册，而不是我的日志，我的其他信息。</li></ol><p>那么如何得到获得上面提到的这些附加的信息呢？OAuth2又单独提供了一个<a href=https://tools.ietf.org/html/rfc7662 target=_blank rel="noopener norefferrer">RFC7662 - OAuth 2.0 Token Introspection</a>来解决Token的描述信息不完整的问题。</p><blockquote><p>这些信息不但对Client不透明，对于资源服务器来说也是不透明的，比如授权服务器和资源服务器是独立部署的，而OAuth2又要求资源服务器要对access token做校验，没有这些信息如何校验呢？除非在access token的db存储层面做共享，但是作为一个运行在互联网规模上的网络环境下的协议，这种假设是无法支撑互联网规模的环境的。</p></blockquote><h1 id=rfc7009-oauth2-token-revocation><i id=locator-rfc7009-oauth2-token-revocation class=header-locator></i>
<a href=#rfc7009-oauth2-token-revocation class=article-h-a>2 RFC7009 OAuth2 Token Revocation</a></h1><p>简单来说，这个协议<a href=https://tools.ietf.org/html/rfc7009 target=_blank rel="noopener norefferrer">RFC7009 - OAuth 2.0 Token Revocation</a>规定了一个Authorization Server提供一个怎样的API来供Client销access_token或者refresh_token。</p><p>比如Client发起一个如下的请求 :</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span>POST /revoke <span style=color:#00f>HTTP</span>/1.1
</span></span><span style=display:flex><span>Host: server.example.com
</span></span><span style=display:flex><span>Content-Type: application/x-www-form-urlencoded
</span></span><span style=display:flex><span>Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>token=45ghiukldjahdnhzdauz&amp;amp;token_type_hint=refresh_token
</span></span></code></pre></div><p>其中各项含义如下 :</p><ol><li><code>/revoke</code> : 是Authorization Server需要提供的API地址，Client使用Post方式请求这个地址。</li><li>Content-Type: application/x-www-form-urlencoded : 固定此格式。</li><li>Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW : 访问受保护资源的授权凭证。</li><li>token : 必选，可以是<code>access_token</code>或者<code>refresh_token</code>的内容。</li><li>token_type_hint : 可选，表示token的类型，值为<code>access_token</code>或者<code>refresh_token</code>。</li></ol><p>如果撤销成功，则返回一个HTTP status code为200的响应就可以了。</p><h1 id=rfc7662-oauth2-token-introspection><i id=locator-rfc7662-oauth2-token-introspection class=header-locator></i>
<a href=#rfc7662-oauth2-token-introspection class=article-h-a>3 RFC7662 OAuth2 Token Introspection</a></h1><p>简单的总结来说，这个<a href=https://tools.ietf.org/html/rfc7662 target=_blank rel="noopener norefferrer">RFC7662 - OAuth 2.0 Token Introspection</a>协议是为OAuth2扩展了一个API接口<code>Introspection Endpoint</code>，让第三方Client可以查询上面提到的那些信息(比如，access_token是否还有效，谁颁发的，颁发给谁的，scope又哪些等等的元数据信息)。</p><p>比如Client发起一个如下的请求 :</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span>POST /introspect <span style=color:#00f>HTTP</span>/1.1
</span></span><span style=display:flex><span>Host: server.example.com
</span></span><span style=display:flex><span>Accept: application/json
</span></span><span style=display:flex><span>Content-Type: application/x-www-form-urlencoded
</span></span><span style=display:flex><span>Authorization: Bearer 23410913-abewfq.123483
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>token=2YotnFZFEjr1zCsicMWpAA&amp;amp;token_type_hint=access_token
</span></span></code></pre></div><p>看起来和上面的撤销Token的请求差不多，其中各项含义如下 :</p><ol><li><code>/introspect</code> : 是Authorization Server需要提供的API地址，Client使用Post方式请求这个地址。</li><li>Accept:application/json : 表示Authorization Server需要返回一个JSON格式的数据。</li><li>Content-Type: application/x-www-form-urlencoded : 固定此格式。</li><li>Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW : 访问受保护资源的授权凭证。</li><li>token : 必选，可以是<code>access_token</code>或者<code>refresh_token</code>的内容。</li><li>token_type_hint : 可选，表示token的类型，值为<code>access_token</code>或者<code>refresh_token</code>。</li></ol><p>如果请求成功，则会返回如下的信息 :</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  &#34;active&#34;: <span style=color:#00f>true</span>,
</span></span><span style=display:flex><span>  &#34;client_id&#34;: <span style=color:#a31515>&#34;l238j323ds-23ij4&#34;</span>,
</span></span><span style=display:flex><span>  &#34;token_type&#34;:<span style=color:#a31515>&#34;access_token&#34;</span>,
</span></span><span style=display:flex><span>  &#34;username&#34;: <span style=color:#a31515>&#34;jdoe&#34;</span>,
</span></span><span style=display:flex><span>  &#34;scope&#34;: <span style=color:#a31515>&#34;read write dolphin&#34;</span>,
</span></span><span style=display:flex><span>  &#34;sub&#34;: <span style=color:#a31515>&#34;Z5O3upPC88QrAjx00dis&#34;</span>,
</span></span><span style=display:flex><span>  &#34;aud&#34;: <span style=color:#a31515>&#34;https://protected.example.net/resource&#34;</span>,
</span></span><span style=display:flex><span>  &#34;iss&#34;: <span style=color:#a31515>&#34;https://server.example.com/&#34;</span>,
</span></span><span style=display:flex><span>  &#34;exp&#34;: 1419356238,
</span></span><span style=display:flex><span>  &#34;iat&#34;: 1419350238,
</span></span><span style=display:flex><span>  &#34;nbf&#34;: 1419350238,
</span></span><span style=display:flex><span>  &#34;jti&#34;: <span style=color:#a31515>&#34;abcdefg&#34;</span>,
</span></span><span style=display:flex><span>  &#34;extension_field&#34;: <span style=color:#a31515>&#34;twenty-seven&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>JSON各项属性含义如下(其中有些信息是在JSON Web Token中定义的，参考链接有详细的介绍):</p><ol><li><code>active</code> : 必须的。表示token是否还是有效的。</li><li><code>client_id</code> : 可选的。表示token所属的Client。比如上面的<strong>在线打印并且包邮的网站</strong>。</li><li><code>token_type</code> : 可选的。表示token的类型。对应传递的token_type_hint。</li><li><code>user_name</code> : 可选的。表示token的授权者的名字。比如上面的<strong>小明</strong>。</li><li><code>scope</code> : 可选的。和上篇<a href=../01-oauth2-authorization/#authorization-request target=_blank rel="noopener norefferrer">5.1.1 Authorization Request</a>中的可选参数scope对应，表示授权给Client访问的范围，比如是相册，而不是小明的日志以及其他受保护资源。<strong>注意这个scope是用户授权的真正的scope, 比如申请授予<code>read write dolphin</code>三个，但是用户可能批准了一个<code>read</code></strong>。</li><li><code>sub</code> : 可选的。token所属的资源拥有者的唯一标识，JWT定义的。也就是小明的唯一标识符。</li><li><code>aud</code> : 可选的。token颁发给谁的，JWT定义的。</li><li><code>iss</code> : 可选的。token的颁发者，JWT定义的。</li><li><code>exp</code> : 可选的。token的过期时间，JWT定义的。</li><li><code>iat</code> : 可选的。iss颁发token的时间，JWT定义的。</li><li><code>nbf</code> : 可选的。token不会在这个时间之前被使用，JWT定义的。</li><li><code>jti</code> : 可选的。token的唯一标识，JWT定义的。</li><li><code>extension_field</code> : 可以自己扩展相关其他属性。</li></ol><p>其中大量的信息都是可选的信息，而且可以自己扩展需要的属性信息，从这些属性中就可以解决我们上面提到的access_token对于Client不透明的问题。</p><p>我们注意到其中有很多属于JWT定义的属性，那么这个JWT是什么东西？它解决了什么问题？</p><h1 id=json-web-token><i id=locator-json-web-token class=header-locator></i>
<a href=#json-web-token class=article-h-a>4 JSON Web Token (JWT)</a></h1><p>简单总结来说，JWT是一个定义一种<strong>紧凑的</strong>，<strong>自包含的</strong>并且提供<strong>防篡改机制</strong>的传递数据的方式的标准协议。</p><p>我们先来看一个简单的示例 :<br><code><br><span style=color:#00f>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span>.<span style=color:green>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6Imxpbmlhbmh1aSJ9</span>.<span style=color:red>hnOfZb95jFwQsYj3qlgFbUu1rKpfTE6AzgXZidEGGTk</span><br></code></p><p>就是这么一堆看起来像是乱码一样的字符串。JWT由3部分构成 : header.payload.signature，每个部分由<code>.</code>来分割开来。</p><h2 id=json-web-token-header><i id=locator-json-web-token-header class=header-locator></i>
<a href=#json-web-token-header class=article-h-a>4.1 Header</a></h2><p>header是一个有效的JSON，其中通常包含了两部分 : token类型和签名算法。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  &#34;alg&#34;: <span style=color:#a31515>&#34;HS256&#34;</span>,
</span></span><span style=display:flex><span>  &#34;typ&#34;: <span style=color:#a31515>&#34;JWT&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>对这个JSON采用base64编码后就是第1部分<br><code><br><span style=color:#00f>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span><br></code></p><h2 id=json-web-token-payload><i id=locator-json-web-token-payload class=header-locator></i>
<a href=#json-web-token-payload class=article-h-a>4.2 Payload</a></h2><p>这一部分代表真正想要传递的数据，包含一组Claims，其中JWT预定义了一些Claim(<a href=#rfc7662-oauth2-token-introspection>RFC7662 OAuth2 Token Introspection</a>)这一节就用到一些JWT预定义的一些Cliam)后面会介绍。关于什么是Claim，可以参考文章末尾给的参考链接。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  &#34;sub&#34;: <span style=color:#a31515>&#34;1234567890&#34;</span>,
</span></span><span style=display:flex><span>  &#34;name&#34;: <span style=color:#a31515>&#34;linianhui&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>对这个JSON采用base64编码后就是第2部分<br><code><br><span style=color:green>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6Imxpbmlhbmh1aSJ9</span><br></code></p><h2 id=json-web-token-signature><i id=locator-json-web-token-signature class=header-locator></i>
<a href=#json-web-token-signature class=article-h-a>4.3 Signature</a></h2><p>这一部分是可选的，由于前面Header和Payload部分是明文的信息，所以这一部分的意义在于保障信息不被篡改用的，生成这部分的方式如下 :</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>HMACSHA256(
</span></span><span style=display:flex><span>  base64UrlEncode(header) + <span style=color:#a31515>&#34;.&#34;</span> + base64UrlEncode(payload),
</span></span><span style=display:flex><span>  secret
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>token生成方使用header中指定的签名算法对<code>header.payload</code>部分进行签名，得到的第3部分<code><span style=color:red>hnOfZb95jFwQsYj3qlgFbUu1rKpfTE6AzgXZidEGGTk</span></code>,然后组合成一个完整的JWT字符串 . 而token消费方在拿到token后, 使用同样的签名算法来生成签名，用来判断<code>header</code>和<code>payload</code>部分有没有被篡改过，因为签名的密钥是只有通信双方知道的，所以可以保证这部分信息不被第三方所篡改。</p><h2 id=json-web-token-signature><i id=locator-json-web-token-signature class=header-locator></i>
<a href=#json-web-token-signature class=article-h-a>4.4 JWT Claims</a></h2><p>JWT规范中预先定义了一些Cliam，但并不是必选的，常用的有 :</p><ol><li><code>iss</code> : Issuer 签发者。</li><li><code>sub</code> : subject签发给的受众，在Issuer范围内是唯一的。</li><li><code>aud</code> : Audience接收方。</li><li><code>exp</code> : Expiration Time过期时间。</li><li><code>iat</code> : Issued At签发时间 等等。</li></ol><p>更完整的一些Claim列表参见 : <a href=https://www.iana.org/assignments/jwt/jwt.xhtml target=_blank rel="noopener norefferrer">https://www.iana.org/assignments/jwt/jwt.xhtml</a></p><p>如果上面这些仍无法满足自己的需要，则可以自定义一些来使用。</p><h2 id=json-web-token-application-scenarios><i id=locator-json-web-token-application-scenarios class=header-locator></i>
<a href=#json-web-token-application-scenarios class=article-h-a>4.5 JWT 应用场景</a></h2><p>由于其采用base64来进行编码，使得它可以安全的用在一些仅限_ASCII_的地方传递信息，比如URL的querystring中。</p><p>比如用户登陆后，可以把用户的一些属性信息(用户标识，是否是管理员，权限有哪些等等可以公开的信息)用JWT编码存储在cookie中，由于其自包含的性质，每次服务器读取到Cookie的时候就可以解析到当前用户对应的属性信息，而不必再次去查询数据库。如果Cookie中每次都发送浪费带宽，也可以用<code>Authorization: Bearer jwttoken</code> 的方式附加到Http Request上去。</p><h1 id=oauth2-and-json-web-token><i id=locator-oauth2-and-json-web-token class=header-locator></i>
<a href=#oauth2-and-json-web-token class=article-h-a>5 OAuth2 & JWT</a></h1><p>注意到我们在<a href=#rfc7662-oauth2-token-introspection>RFC7662 OAuth2 Token Introspection</a>这一小节中，OAuth2返回Token的元数据的JSON，以及OAuth2中的access_token对Client是不透明的字符串这件事，我们可以把access_token的元数据信息用JWT来编码，作为access_token的字符串内容，这样是不是就可以使得它对Client是透明的了。</p><p>比如我之前遇到的问题，在我使用access_token的时候有没有过期我并不知道，其实需要借助辅助的<code>expires_in</code>来检查，还有其scope是哪些，也需要额外的去查询，再比如这个access_token管理的用户是谁，也需要额外的查询，有了JWT呢，可以把这些都打包进去，比如 :</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  &#34;sub&#34;:<span style=color:#a31515>&#34;linianhui&#34;</span>,
</span></span><span style=display:flex><span>  &#34;scope&#34;:<span style=color:#a31515>&#34;1419356238&#34;</span>,
</span></span><span style=display:flex><span>  &#34;exp&#34;:123456789,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>然后生成一个这样的jwt字符串<code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJsaW5pYW5odWkiLCJzY29wZSI6IjE0MTkzNTYyMzgiLCJleHAiOjEyMzQ1Njc4OX0.ASu85ohHMSOhnxbJSJI4OKLsPlbjPs7th0Xw5-b4l1A</code>作为access_token，感觉一下子就方便了好多吧。</p><h1 id=summary><i id=locator-summary class=header-locator></i>
<a href=#summary class=article-h-a>6 总结</a></h1><p>OAuth2在RFC6749中并未完整的提供一些问题的解决方案，而是附加了一些相关的RFC来解决这些问题，其实除了本文中提到的2个问题点之外，还有一些其他可以优化的地方存在(比如服务发现 : <a href=https://tools.ietf.org/html/draft-ietf-oauth-discovery-06 target=_blank rel="noopener norefferrer">https://tools.ietf.org/html/draft-ietf-oauth-discovery-06</a>，From Post Response Mode :<a href=http://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html target=_blank rel="noopener norefferrer">http://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html</a>)，这些点在后续的OIDC的文章中再做介绍吧，感兴趣的可以看一看<a href=http://openid.net/connect/ target=_blank rel="noopener norefferrer">http://openid.net/connect/</a>中关于OAuth2的另外一些相关扩展标准草案，这些标准也是OIDC所需要的一些可选支持；以及OAuth相关扩展草案 : <a href=https://datatracker.ietf.org/wg/oauth/charter/ target=_blank rel="noopener norefferrer">https://datatracker.ietf.org/wg/oauth/charter/</a>。另外在一些场景下，使用JWT来使得OAuth2的提供自包含的Token还是一件很方便的事情的。</p><p>以上内容均是个人的一些理解，如果错误之处，欢迎指正！</p><h1 id=reference><i id=locator-reference class=header-locator></i>
<a href=#reference class=article-h-a>7 参考资料</a></h1><p>JSON协议 : <a href=https://tools.ietf.org/html/rfc7159 target=_blank rel="noopener norefferrer">RFC7159 - The JavaScript Object Notation (JSON) Data Interchange Format</a></p><p>OAuth2 扩展协议 :</p><p><a href=https://tools.ietf.org/html/rfc7009 target=_blank rel="noopener norefferrer">RFC7009 - OAuth 2.0 Token Revocation</a></p><p><a href=https://tools.ietf.org/html/rfc7662 target=_blank rel="noopener norefferrer">RFC7662 - OAuth 2.0 Token Introspection</a></p><p>OAuth相关扩展草案 :</p><p><a href=https://datatracker.ietf.org/wg/oauth/charter/ target=_blank rel="noopener norefferrer">https://datatracker.ietf.org/wg/oauth/charter/</a></p><p><a href=https://tools.ietf.org/wg/oauth/ target=_blank rel="noopener norefferrer">https://tools.ietf.org/wg/oauth/</a></p><p>JWT相关协议族 :</p><p><a href=https://tools.ietf.org/html/rfc7515 target=_blank rel="noopener norefferrer">RFC7515 - JSON Web Signature (JWS)</a></p><p><a href=https://tools.ietf.org/html/rfc7516 target=_blank rel="noopener norefferrer">RFC7516 - JSON Web Encryption (JWE)</a></p><p><a href=https://tools.ietf.org/html/rfc7517 target=_blank rel="noopener norefferrer">RFC7517 - JSON Web Key (JWK)</a></p><p><a href=https://tools.ietf.org/html/rfc7518 target=_blank rel="noopener norefferrer">RFC7518 - JSON Web Algorithms (JWA)</a></p><p><a href=https://tools.ietf.org/html/rfc7519 target=_blank rel="noopener norefferrer">RFC7519 - JSON Web Token (JWT)</a></p><p>JWT官方站点 : <a href=https://jwt.io/ target=_blank rel="noopener norefferrer">https://jwt.io</a></p><p>Claims : <a href=https://en.wikipedia.org/wiki/Claims-based_identity target=_blank rel="noopener norefferrer">https://en.wikipedia.org/wiki/Claims-based_identity</a></p><p>JWT注册的的一组Claims : <a href=https://www.iana.org/assignments/jwt/jwt.xhtml target=_blank rel="noopener norefferrer">https://www.iana.org/assignments/jwt/jwt.xhtml</a></p></section><section class=article-meta><section class=article-date>2017-04-03 03:56，约4390字，阅读约9分钟</section><section class=article-topics><a class=article-topic href=/authentication-and-authorization/ title=[认证&授权] target=_blank><i class="fa fa-folder"></i>[认证&授权]</a></section><section class=article-tags><a class=article-tag href=/tag/jwt target=_blank><i class="fa fa-tag"></i>JWT</a>
<a class=article-tag href=/tag/oauth2 target=_blank><i class="fa fa-tag"></i>OAuth2</a></section><section class=article-git><a class=article-git-commit href=https://github.com/linianhui/blog/commit/03e0cc08866458647d96951c1817c624518149d6 target=_blank><i class="fa fa-code-fork"></i>03e0cc0</a>
<span class=article-git-commit-subject>fix add displayed_on_home</span>
<span class=article-git-commit-time>2022-11-20 14:49</span>
<a class=article-git-source href=https://github.com/linianhui/blog/blob/main/src/authentication-and-authorization/02-oauth2-extensions-protocol-and-json-web-token/index.md target=_blank><i class="fa fa-github"></i>源码</a></section></section><section class=article-page><div class=article-page-prev><span>上一篇 : </span><a href=/authentication-and-authorization/01-oauth2-authorization/ target=_blank>[认证&授权] 01 OAuth2授权</a></div><div class=article-page-next><span>下一篇 : </span><a href=/authentication-and-authorization/03-user-authentication-with-oauth2/ target=_blank>[认证&授权] 03 使用OAuth2进行用户认证(译)</a></div></section></article><section id=article-comment class=article-comment><script src=https://utteranc.es/client.js repo=linianhui/blog issue-term=pathname label=blog-comment theme=github-light crossorigin=anonymous async></script></section></main><footer class=footer><section>Copyright © 2025 by <a href=https://github.com/linianhui/blog target=_blank>Timetombs</a></section><section><a class=article-git-commit href=https://github.com/linianhui/blog/commit/2fac07e818d6d4ad6b78781efea82c28769c8c02 target=_blank><i class="fa fa-code-fork"></i>2fac07e</a>
Powered by
<a href=https://github.com/actions target=_blank>GitHub Actions</a>
,
<a href=https://github.com/gohugoio/hugo target=_blank>Hugo</a>
and
<a href=https://github.com/utterance/utterances target=_blank>utterances</a>
Hosted on <a href=https://pages.github.com/ target=_blank>GitHub Pages</a><section></footer></main><aside class=toolbar><a class="fa fa-list" href=javascript:blog.toggleToc(); title=目录></a><a class="fa fa-comments" href=#article-comment title=评论></a><a class="fa fa-arrow-up" href=javascript:scroll(0,0); title=返回顶部></a></aside><script type=text/javascript>var _hmt=_hmt||[];blog.addOnScorllEvent()</script><script src=https://hm.baidu.com/hm.js?b2cc3cea316e1f7a8def1bab8dc98fad async></script></body></html>