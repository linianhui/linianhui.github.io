<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=google-site-verification content="X6gTMGCy1-_vb5i3aja3ZZyzPY3raiKRJp4VIhOAX24"><meta name=msvalidate.01 content="CDE7502649B75529BD0FCFE89B056E38"><title>[OIDC in Action] 03 基于OIDC的SSO - GitHub OP - Timetombs</title>
<link rel=icon type=image/svg href=/favicon.svg><link rel=stylesheet href=https://s4.zstatic.net/ajax/libs/normalize/8.0.1/normalize.min.css crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://s4.zstatic.net/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css crossorigin=anonymous referrerpolicy=no-referrer><link href='/asset/blog.css?time=2026-01-25T21%3a48%3a01Z%2b08%3a00' rel=stylesheet type=text/css><script src=https://s4.zstatic.net/npm/currency.js@2.0.4/dist/currency.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://s4.zstatic.net/ajax/libs/moment.js/2.30.1/moment.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script src='/asset/blog.js?time=2026-01-25T21%3a48%3a01Z%2b08%3a00' type=application/javascript></script><script type=text/javascript>blog.isMobile()&&document.write('<link href="/asset/blog.mobile.css?time=2026-01-25T21%3A48%3A01Z%2B08%3A00" rel="stylesheet">')</script></head><body><div id=horizontal-progress class=horizontal-progress></div><aside id=toc class=toc><section class=toc-header><a class=toc-page-title href=/oidc-in-action/ target=_blank>[OIDC in Action]</a></section><section class=toc-page><a class=toc-page-title href=/oidc-in-action/01-oidc-sso/ target=_blank>[OIDC in Action] 01 基于OIDC的SSO</a></section><section class=toc-page><a class=toc-page-title href=/oidc-in-action/02-oidc-sso-js-client/ target=_blank>[OIDC in Action] 02 基于OIDC的SSO - JS Client</a></section><section class="toc-page selected"><span class=toc-page-title>[OIDC in Action] 03 基于OIDC的SSO - GitHub OP</span><nav id=TableOfContents><ul><li><a href=#oidc-client>1 OIDC Client</a><ul><li><a href=#use-github-idp>1.1 指定oidc-server.test使用Github认证(可选)</a></li></ul></li><li><a href=#oidc-server>2 OIDC Server</a><ul><li><a href=#oidc-server-idp>2.1 识别客户端发送的IDP信息</a></li><li><a href=#github-login>2.2 集成Github登录</a></li><li><a href=#github-login-callback>2.3 处理Github OAuth 2.0 的回调</a></li><li><a href=#association-github-user>2.4 关联Github用户</a></li><li><a href=#redirect-to-client>2.5 构造id_token & 重定向到客户端</a></li></ul></li><li><a href=#summary>3 总结</a></li><li><a href=#reference>4 参考资料</a></li></ul></nav></section><script type=text/javascript>blog.isPC()&&blog.toggleToc()</script></aside><main class=main><header class=header><hgroup class=header-hgroup><h1 class=header-hgroup-title><a href=/>Timetombs</a></h1><h2 class=header-hgroup-subtitle>泛义的工具是文明的基础，而确指的工具却是愚人的器物</h2></hgroup><nav class=header-nav><a class=header-nav-item href=/topic/ title=专题 target=_self><i class="fa fa-folder"></i>专题</a>
<a class=header-nav-item href=/tag/ title=标签 target=_self><i class="fa fa-tags"></i>标签</a>
<a class=header-nav-item href=/archive/ title=归档 target=_self><i class="fa fa-archive"></i>归档</a>
<a class=header-nav-item href=https://linianhui.cnblogs.com title=博客园 target=_black><img src=/asset/cnblogs.favicon.svg>博客园</a>
<a class=header-nav-item href=https://github.com/linianhui/blog title=GitHub target=_black><i class="fa fa-github"></i>GitHub</a></nav><div class=header-stats><div class=stats><span>共
<i>66<sub>h</sub>
</i>/
<i>118<sub>a</sub>
</i>篇</span><div class=stats-date>，更新于 2026-01-25T21:48:01Z+08:00 by &nbsp;
<a class=git-commit href=https://github.com/linianhui/blog/commit/39b6c03faec1d2881596df2cd2436da10cdf9eef target=_blank><i class="fa fa-code-fork"></i>39b6c03</a></div></div><form class=search method=GET target=_blank action=https://www.bing.com/search><input name=q class=search-input type=search placeholder=search... results=5 onkeypress="search_param.value=search_param_site.value+this.value">
<input id=search_param_site type=hidden value="site:linianhui.github.io ">
<input name=q id=search_param type=hidden></form></div></header><main class=content><article class=article><h1 class=article-title>[OIDC in Action] 03 基于OIDC的SSO - GitHub OP</h1><div class=article-copyright><span>版权声明 - </span><a href=/copyright/cc target=_blank>CC BY-NC-SA 4.0</a></div><section class=article-meta><section class=article-date>2018-12-01 10:41，约3488字，阅读约7分钟</section><section class=article-topics><a class=article-topic href=/oidc-in-action/ title="[OIDC in Action]" target=_blank><i class="fa fa-folder"></i>[OIDC in Action]</a></section><section class=article-tags><a class=article-tag href=/tag/acr_values target=_blank><i class="fa fa-tag"></i>acr_values</a>
<a class=article-tag href=/tag/idp target=_blank><i class="fa fa-tag"></i>IDP</a>
<a class=article-tag href=/tag/oidc target=_blank><i class="fa fa-tag"></i>OIDC</a>
<a class=article-tag href=/tag/op target=_blank><i class="fa fa-tag"></i>OP</a>
<a class=article-tag href=/tag/openid-connect target=_blank><i class="fa fa-tag"></i>OpenId Connect</a>
<a class=article-tag href=/tag/openid-provider target=_blank><i class="fa fa-tag"></i>OpenID Provider</a>
<a class=article-tag href=/tag/sso target=_blank><i class="fa fa-tag"></i>SSO</a></section><section class=article-git><a class=article-git-commit href=https://github.com/linianhui/blog/commit/03e0cc08866458647d96951c1817c624518149d6 target=_blank><i class="fa fa-code-fork"></i>03e0cc0</a>
<span class=article-git-commit-subject>fix add displayed_on_home</span>
<span class=article-git-commit-time>2022-11-20 14:49</span>
<a class=article-git-source href=https://github.com/linianhui/blog/blob/main/src/oidc-in-action/03-oidc-sso-github-op/index.md target=_blank><i class="fa fa-github"></i>源码</a></section></section><section class=article-content><p>在上上一篇<a href=../01-oidc-sso/ target=_blank rel="noopener norefferrer">[OIDC in Action] 01 基于OIDC的SSO</a>的登录页面的截图中有出现QQ登录的地方。这个其实是通过扩展OIDC的OpenID Provider来实现的，OpenID Provider简称OP，OP是OIDC的一个很重要的角色，OIDC用它来实现兼容众多的用户认证方式的，比如基于OAuth2，SAML和WS-Federation等等的用户认证方式。关于OP在<a href=/authentication-and-authorization/04-openid-connect-core/ target=_blank rel="noopener norefferrer">[认证&授权] 04 OIDC(OpenId Connect)身份认证(核心部分)</a>中有提到过，但是并未详细解释。</p><blockquote><p>由于QQ的开发者账号申请不方便，故而在一下的示例中使用了Github的OAuth 2.0作为替代(原理是一模一样的)，源码<a href=https://github.com/linianhui/oidc.example/pull/14 target=_blank rel="noopener norefferrer">Add Github OAuth2 as OIDC OpenID Provider</a>。</p><p>由于dev顶级域名已被Google所持有并且强制Chrome对dev使用https(不便于查看http消息)，故而<a href=https://github.com/linianhui/oidc.example/commit/60f8da75a237144d5ab5c06d17aae3cd739792cb target=_blank rel="noopener norefferrer">改为了test顶级域名</a>。</p></blockquote><p>上一篇博客中的登录时采用的本地的账户和密码来运行的。本篇则为OIDC Server添加一个OP : <code>Github OAuth 2.0</code>。这就使得oidc-server.test可以使>Github来登录，并且SSO的客户端可以不做任何改动(除非客户端需要指定采用何种认证方式，即使如此也是非常非常微小的改动)。本篇涉及到的部分有(本系列的源代码位于<a href=https://github.com/linianhui/oidc.example target=_blank rel="noopener norefferrer">https://github.com/linianhui/oidc.example</a>) :</p><ol><li><a href=https://github.com/linianhui/oidc.example/blob/master/1-src/oauth2.github.aspnetcore target=_blank rel="noopener norefferrer">oauth2.github.aspnetcore</a>这个项目，它基于aspnetcore2实现了Github OAuth 2.0认证。</li><li><a href=http://oidc-server.test target=_blank rel="noopener norefferrer">oidc-server.test</a>站点，对应的是<a href=https://github.com/linianhui/oidc.example/blob/master/1-src/web.oidc.server.ids4 target=_blank rel="noopener norefferrer">web.oidc.server.ids4</a>这个项目，引用了上面的这个项目。</li><li><a href=http://oidc-client-implicit.test target=_blank rel="noopener norefferrer">oidc-client-implicit.test</a>站点，作为oidc的客户端，Github登录的最终消费者(它无需关注Github登录的任何细节)。</li></ol><h1 id=oidc-client><i id=locator-oidc-client class=header-locator></i>
<a href=#oidc-client class=article-h-a>1 OIDC Client</a></h1><h2 id=use-github-idp><i id=locator-use-github-idp class=header-locator></i>
<a href=#use-github-idp class=article-h-a>1.1 指定oidc-server.test使用Github认证(可选)</a></h2><p>下图是上一篇中起始页面，这次我们点击Oidc Login(Github)这个链接(客户端也可以不指定采用Github进行认证，推迟到进入<a href=http://oidc-server.test target=_blank rel="noopener norefferrer">oidc-server.test</a>之后进行选择)。<br><img src=1.1.github-op.png loading=lazy decoding=auto alt title></p><p>我们知道这个链接会返回一个302重定向，重定向的地址是发往<a href=http://oidc-server.test target=_blank rel="noopener norefferrer">oidc-server.test</a>的认证请求，我们看下这个请求和<a href=../01-oidc-sso/#oidc-client-send-authentication-request target=_blank rel="noopener norefferrer">上一次</a>有什么差异 :<br><img src=1.1.github-op-http.png loading=lazy decoding=auto alt title></p><p>除了红色部分之外，其他地方并没有任何的不同。那么我们就可以理解为时<code>acr_values=idp:github</code> (<em>其中idp是Identity Provider的缩写，即身份提供商，和OP的OpenId Provider属于一类含义，只是不同的叫法</em>)这个参数改变了oidc-server.test的认证行为，使其选择了Github进行登录。</p><p>至此我们可以得出一个结论，那就是Github登录无需在<a href=http://oidc-server.test target=_blank rel="noopener norefferrer">oidc-server.test</a>的客户端这边进行处理，只需指定一个参数即可，比如如果<a href=http://oidc-server.test target=_blank rel="noopener norefferrer">oidc-server.test</a>还支持了微信登录，那么客户端就可以通过传递<code>acr_values=idp:wechat</code>即可直接使用微信登录。但是oidc-server.test内部是怎么实现的呢？这里有两件事情需要处理 :</p><ol><li><a href=http://oidc-server.test target=_blank rel="noopener norefferrer">oidc-server.test</a>要能够识别oidc客户端传递过来的这个参数，如果参数有效，则使用参数指定的OP进行登录，如果没有指定，则采用默认的登录方式(本地的用户和密码体系)。参数是 <a href=http://openid.net/specs/openid-connect-core-1_0.html#rfc.section.3.1.2.1 target=_blank rel="noopener norefferrer">acr_values(Authentication Context Class Reference values)</a>，它是oidc协议规定的一个参数，Ids4实现了对这个参数的支持。</li><li><a href=http://oidc-server.test target=_blank rel="noopener norefferrer">oidc-server.test</a>需要支持使用Github进行登录，并且关联到ids4组件。</li></ol><p>下面我们看看<a href=http://oidc-server.test target=_blank rel="noopener norefferrer">oidc-server.test</a>这个站点是如何完成这两件事情的。</p><h1 id=oidc-server><i id=locator-oidc-server class=header-locator></i>
<a href=#oidc-server class=article-h-a>2 OIDC Server</a></h1><h2 id=oidc-server-idp><i id=locator-oidc-server-idp class=header-locator></i>
<a href=#oidc-server-idp class=article-h-a>2.1 识别客户端发送的IDP信息</a></h2><p>在<a href=http://oidc-server.test target=_blank rel="noopener norefferrer">oidc-server.test</a>这个站点中，在集成ids4组件的时候，有这么一段代码 :</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#00f>public</span> <span style=color:#00f>static</span> IServiceCollection AddIds4(<span style=color:#00f>this</span> IServiceCollection @this)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    @this
</span></span><span style=display:flex><span>        .AddAuthentication()
</span></span><span style=display:flex><span>        .AddQQConnect(<span style=color:#a31515>&#34;qq&#34;</span>, <span style=color:#a31515>&#34;QQ Connect&#34;</span>, SetQQConnectOptions)
</span></span><span style=display:flex><span>        .AddGithub(<span style=color:#a31515>&#34;github&#34;</span>, <span style=color:#a31515>&#34;Github&#34;</span>, SetGithubOptions);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    @this
</span></span><span style=display:flex><span>        .AddIdentityServer(SetIdentityServerOptions)
</span></span><span style=display:flex><span>        .AddDeveloperSigningCredential()
</span></span><span style=display:flex><span>        .AddInMemoryIdentityResources(Resources.AllIdentityResources)
</span></span><span style=display:flex><span>        .AddInMemoryApiResources(Resources.AllApiResources)
</span></span><span style=display:flex><span>        .AddInMemoryClients(Clients.All)
</span></span><span style=display:flex><span>        .AddTestUsers(Users.All);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     <span style=color:#00f>return</span> @this;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>private</span> <span style=color:#00f>static</span> <span style=color:#00f>void</span> SetGithubOptions(GithubOAuthOptions options)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    options.SignInScheme = IdentityServerConstants.ExternalCookieAuthenticationScheme;
</span></span><span style=display:flex><span>    options.ClientId = GlobalConfig.Github.ClientId;
</span></span><span style=display:flex><span>    options.ClientSecret = GlobalConfig.Github.ClientSecret;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>AddGithub</code>这个扩展方法是我自己写的，位于文章开始提到的<a href=https://github.com/linianhui/oidc.example/blob/master/1-src/oauth2.github.aspnetcore target=_blank rel="noopener norefferrer">oauth2.github.aspnetcore</a>项目中。我们暂且先不关注其内部是如何实现的，这里有两个重要的信息。</p><ol><li><code>github</code>，这是方法的第1个参数，指定了Github作为aspnetcore这个框架种支持的一种认证方式的唯一标识符，也就是一个scheme名字。</li><li><code>options.SignInScheme = IdentityServerConstants.ExternalCookieAuthenticationScheme;</code> 其含义是把上面指定的<code>github</code>这个认证方式，作为ids4的外部登录来使用。其实ExternalCookieAuthenticationScheme 也是个字符串而已 <code>public const string ExternalCookieAuthenticationScheme = "idsrv.external";</code> ，这个字符串是ids4定义的一个外部登录的sheme名字。所有的外部登录如果想要和ids4集成，都需要使用它来关联。</li></ol><h2 id=github-login><i id=locator-github-login class=header-locator></i>
<a href=#github-login class=article-h-a>2.2 集成Github登录</a></h2><p>有了上述两个信息，ids4就可以在接收到<code>acr_values=idp:github</code>这样的参数时，自动的从aspnetcore框架中已经注册的认证scheme中查找名为<code>gtihub</code>的认证方式，然后来触Github登录的流程。并且在Github认证完成后，进入ids4定义的外部登录流程中。从Fiddler中可以看到这个重定向的过程 :<br><img src=2.2.redirect-github.png loading=lazy decoding=auto alt title></p><p>然后Github就打开了它的登录页面 :<br><img src=2.2.github-login.png loading=lazy decoding=auto alt title></p><p>这部分的控制代码位于<a href=https://github.com/linianhui/oidc.example/blob/master/1-src/oauth2.github.aspnetcore/GithubOAuthHandler.cs target=_blank rel="noopener norefferrer">GithubOAuthHandler</a>继承的<a href=https://github.com/aspnet/AspNetCore/blob/master/src/Security/src/Microsoft.AspNetCore.Authentication.OAuth/OAuthHandler.cs#L220 target=_blank rel="noopener norefferrer">OAuthHandler</a>基类<code>BuildChallengeUrl(AuthenticationProperties properties,string redirectUri)</code>方法中 :</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#00f>protected</span> <span style=color:#00f>virtual</span> <span style=color:#2b91af>string</span> BuildChallengeUrl(AuthenticationProperties properties, <span style=color:#2b91af>string</span> redirectUri)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> scopeParameter = properties.GetParameter&lt;ICollection&lt;<span style=color:#2b91af>string</span>&gt;&gt;(OAuthChallengeProperties.ScopeKey);
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> scope = scopeParameter != <span style=color:#00f>null</span> ? FormatScope(scopeParameter) : FormatScope();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> state = Options.StateDataFormat.Protect(properties);
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> parameters = <span style=color:#00f>new</span> Dictionary&lt;<span style=color:#2b91af>string</span>, <span style=color:#2b91af>string</span>&gt;
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>         { <span style=color:#a31515>&#34;client_id&#34;</span>, Options.ClientId },
</span></span><span style=display:flex><span>         { <span style=color:#a31515>&#34;scope&#34;</span>, scope },
</span></span><span style=display:flex><span>         { <span style=color:#a31515>&#34;response_type&#34;</span>, <span style=color:#a31515>&#34;code&#34;</span> },
</span></span><span style=display:flex><span>         { <span style=color:#a31515>&#34;redirect_uri&#34;</span>, redirectUri },
</span></span><span style=display:flex><span>         { <span style=color:#a31515>&#34;state&#34;</span>, state },
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> QueryHelpers.AddQueryString(Options.AuthorizationEndpoint, parameters);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>BuildChallengeUrl</code>方法返回的URL地址，正是上图中Github的认证页面。</p><h2 id=github-login-callback><i id=locator-github-login-callback class=header-locator></i>
<a href=#github-login-callback class=article-h-a>2.3 处理Github OAuth 2.0 的回调</a></h2><p>然后输入账号密码登录Github,随后Github会采用OAuth 2.0的流程，重定向到<a href=http://oidc-server.test target=_blank rel="noopener norefferrer">oidc-server.test</a>的回调地址上。<br><img src=2.3.github-login-callback.png loading=lazy decoding=auto alt title></p><p>这个回调地址是标准的OAuth 2的流程，返回了code和state参数，<a href=https://github.com/aspnet/AspNetCore/blob/master/src/Security/src/Microsoft.AspNetCore.Authentication.OAuth/OAuthHandler.cs#L45 target=_blank rel="noopener norefferrer">OAuthHandler</a>类的<code>protected override async Task&lt;HandleRequestResult> HandleRemoteAuthenticateAsync()</code>方法会根据code得到github的access_token，然后进一步的获取到github的用户信息(位于<a href=https://github.com/linianhui/oidc.example/blob/master/1-src/oauth2.github.aspnetcore/GithubOAuthHandler.cs target=_blank rel="noopener norefferrer">GithubOAuthHandler</a>)。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#00f>protected</span> <span style=color:#00f>override</span> <span style=color:#00f>async</span> Task&lt;AuthenticationTicket&gt; CreateTicketAsync(
</span></span><span style=display:flex><span>    ClaimsIdentity identity,
</span></span><span style=display:flex><span>    AuthenticationProperties properties, 
</span></span><span style=display:flex><span>    OAuthTokenResponse tokens)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>     <span style=color:#2b91af>var</span> httpRequestMessage = <span style=color:#00f>new</span> HttpRequestMessage(HttpMethod.Get, <span style=color:#00f>base</span>.Options.UserInformationEndpoint);
</span></span><span style=display:flex><span>     httpRequestMessage.Headers.Authorization = <span style=color:#00f>new</span> AuthenticationHeaderValue(<span style=color:#a31515>&#34;Bearer&#34;</span>, tokens.AccessToken);
</span></span><span style=display:flex><span>     <span style=color:#2b91af>var</span> httpResponseMessage = awaitbase.Backchannel.SendAsync(httpRequestMessage, <span style=color:#00f>base</span>.Context.RequestAborted);
</span></span><span style=display:flex><span>    <span style=color:#00f>if</span> (!httpResponseMessage.IsSuccessStatusCode)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#00f>throw</span> <span style=color:#00f>new</span> HttpRequestException(<span style=color:#a31515>$&#34;An error occurred when retrieving Github user information ({httpResponseMessage.StatusCode}).&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> user = JObject.Parse(<span style=color:#00f>await</span> httpResponseMessage.Content.ReadAsStringAsync());
</span></span><span style=display:flex><span>    <span style=color:#2b91af>var</span> context = <span style=color:#00f>new</span> OAuthCreatingTicketContext(<span style=color:#00f>new</span> ClaimsPrincipal(identity), properties, <span style=color:#00f>base</span>.Context, <span style=color:#00f>base</span>.Scheme, <span style=color:#00f>base</span>.Options, <span style=color:#00f>base</span>.Backchannel, tokens, user);
</span></span><span style=display:flex><span>    context.RunClaimActions();
</span></span><span style=display:flex><span>    <span style=color:#00f>await</span> <span style=color:#00f>base</span>.Events.CreatingTicket(context);
</span></span><span style=display:flex><span>    <span style=color:#00f>return</span> <span style=color:#00f>new</span> AuthenticationTicket(context.Principal, context.Properties, <span style=color:#00f>base</span>.Scheme.Name);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>随后把这些信息加密保存到了名为<code>idsrv.external</code>(还记得在一开始的时候设置的<code>options.SignInScheme = IdentityServerConstants.ExternalCookieAuthenticationScheme</code>吧)的cookie中。</p><h2 id=association-github-user><i id=locator-association-github-user class=header-locator></i>
<a href=#association-github-user class=article-h-a>2.4 关联Github用户</a></h2><p>在上一步保存完github的用户信息到cookie中后，ids4便开始根据github的用户信息查找是否已经绑定了已有的用户，如果没有则新建一个。我这里模拟了一个新建用户的页面(简单的设置了下昵称和用户头像-来自github) :<br><img src=2.4.0.png loading=lazy decoding=auto alt title></p><p>随后，ids4保存这个新用户的信息，并且用它登录系统(并清空保存的github的用户信息)。<br><img src=2.4.1.png loading=lazy decoding=auto alt title></p><h2 id=redirect-to-client><i id=locator-redirect-to-client class=header-locator></i>
<a href=#redirect-to-client class=article-h-a>2.5 构造id_token & 重定向到客户端</a></h2><p>随后的流程就和<a href=../01-oidc-sso/#oidc-server-login-completed target=_blank rel="noopener norefferrer">[OIDC in Action] 01 基于OIDC的SSO - 2.1 OIDC-Client 触发登出请求</a>时一样的了，这里就不介绍了，完成后客户端或得到了id_token，读取到了其中的github的用户信息。<br><img src=2.5.0.png loading=lazy decoding=auto alt title></p><h1 id=summary><i id=locator-summary class=header-locator></i>
<a href=#summary class=article-h-a>3 总结</a></h1><p>剖析oidc-server.test如何利用ids4来扩展第三方的登录认证方式。文章中的例子是利用ids4来处理的，其他的比如node.js或者java等等平台，代码也许不一样，但是核心流程是一样的 :</p><ol><li>即先使用github登录，获取到认证用户的信息。</li><li>然后利用这些信息链接到自有账号体系，最终使用自有的账号体系完成认证。</li><li>扩展登录的信息可以根据需要放到发放给客户端的idtoken中，但是只是作为辅助信息存在的。</li></ol><p>本例只是使用OAuth 2.0(IDP)作为了OIDC的OP，但是并不仅限于此，还支持SAML，WS-Federation，Windows AD，或者常用的手机短信验证码等等方式，其实OIDC并不关系是如何完成用户认证的，它关心的只是得到用户认证的信息后，按照统一的规范的流程把这个认证信息(id_token)安全的给到OIDC的客户端即可。</p><p>如有错误指出，欢迎指正!</p><h1 id=reference><i id=locator-reference class=header-locator></i>
<a href=#reference class=article-h-a>4 参考资料</a></h1><p>idp vs op : <a href=http://lists.openid.net/pipermail/openid-specs/2006-November/003807.html target=_blank rel="noopener norefferrer">http://lists.openid.net/pipermail/openid-specs/2006-November/003807.html</a></p><p>acr_values : <a href=http://openid.net/specs/openid-connect-core-1_0.html#rfc.section.3.1.2.1 target=_blank rel="noopener norefferrer">http://openid.net/specs/openid-connect-core-1_0.html#rfc.section.3.1.2.1</a></p><p>Github OAuth文档 : <a href=https://developer.github.com/apps/building-oauth-apps/authorizing-oauth-apps/ target=_blank rel="noopener norefferrer">https://developer.github.com/apps/building-oauth-apps/authorizing-oauth-apps/</a></p><p>ids4 Sign-in with External Identity Providers : <a href=https://identityserver4.readthedocs.io/en/release/topics/signin_external_providers.html target=_blank rel="noopener norefferrer">https://identityserver4.readthedocs.io/en/release/topics/signin_external_providers.html</a></p></section><section class=article-meta><section class=article-date>2018-12-01 10:41，约3488字，阅读约7分钟</section><section class=article-topics><a class=article-topic href=/oidc-in-action/ title="[OIDC in Action]" target=_blank><i class="fa fa-folder"></i>[OIDC in Action]</a></section><section class=article-tags><a class=article-tag href=/tag/acr_values target=_blank><i class="fa fa-tag"></i>acr_values</a>
<a class=article-tag href=/tag/idp target=_blank><i class="fa fa-tag"></i>IDP</a>
<a class=article-tag href=/tag/oidc target=_blank><i class="fa fa-tag"></i>OIDC</a>
<a class=article-tag href=/tag/op target=_blank><i class="fa fa-tag"></i>OP</a>
<a class=article-tag href=/tag/openid-connect target=_blank><i class="fa fa-tag"></i>OpenId Connect</a>
<a class=article-tag href=/tag/openid-provider target=_blank><i class="fa fa-tag"></i>OpenID Provider</a>
<a class=article-tag href=/tag/sso target=_blank><i class="fa fa-tag"></i>SSO</a></section><section class=article-git><a class=article-git-commit href=https://github.com/linianhui/blog/commit/03e0cc08866458647d96951c1817c624518149d6 target=_blank><i class="fa fa-code-fork"></i>03e0cc0</a>
<span class=article-git-commit-subject>fix add displayed_on_home</span>
<span class=article-git-commit-time>2022-11-20 14:49</span>
<a class=article-git-source href=https://github.com/linianhui/blog/blob/main/src/oidc-in-action/03-oidc-sso-github-op/index.md target=_blank><i class="fa fa-github"></i>源码</a></section></section><section class=article-page><div class=article-page-prev><span>上一篇 : </span><a href=/oidc-in-action/02-oidc-sso-js-client/ target=_blank>[OIDC in Action] 02 基于OIDC的SSO - JS Client</a></div></section></article><section id=article-comment class=article-comment><script src=https://utteranc.es/client.js repo=linianhui/blog issue-term=pathname label=blog-comment theme=github-light crossorigin=anonymous async></script></section></main><footer class=footer><section>Copyright © 2026 by <a href=https://github.com/linianhui/blog target=_blank>Timetombs</a></section><section><a class=article-git-commit href=https://github.com/linianhui/blog/commit/39b6c03faec1d2881596df2cd2436da10cdf9eef target=_blank><i class="fa fa-code-fork"></i>39b6c03</a>
Powered by
<a href=https://github.com/actions target=_blank>GitHub Actions</a>
,
<a href=https://github.com/gohugoio/hugo target=_blank>Hugo</a>
and
<a href=https://github.com/utterance/utterances target=_blank>utterances</a>
Hosted on <a href=https://pages.github.com/ target=_blank>GitHub Pages</a><section></footer></main><aside class=toolbar><a class="fa fa-list" href=javascript:blog.toggleToc(); title=目录></a><a class="fa fa-comments" href=#article-comment title=评论></a><a class="fa fa-arrow-up" href=javascript:scroll(0,0); title=返回顶部></a></aside><script type=text/javascript>var _hmt=_hmt||[];blog.addOnScorllEvent()</script></body></html>